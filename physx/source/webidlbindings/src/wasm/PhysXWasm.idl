//
// Emscripten / Web IDL Binder compatible .idl file
// Generated by webidl-util from model physx-js-webidl
//

[NoDelete]
interface ArrayHelpers {
    static PxContactPair getContactPairAt(PxContactPair base, unsigned long index);
    static PxTriggerPair getTriggerPairAt(PxTriggerPair base, unsigned long index);
    static PxDebugPoint getDebugPointAt(PxDebugPoint base, unsigned long index);
    static PxDebugLine getDebugLineAt(PxDebugLine base, unsigned long index);
    static PxDebugTriangle getDebugTriangleAt(PxDebugTriangle base, unsigned long index);
};

[NoDelete]
interface ExtensionFunctions {
    static PxArticulationTendonJoint PxArticulationFixedTendon_getTendonJoint([Const, Ref] PxArticulationFixedTendon tendon, unsigned long index);
    static PxArticulationLink PxArticulationLink_getChild([Const, Ref] PxArticulationLink link, unsigned long index);
    static PxArticulationLink PxArticulationReducedCoordinate_getLink([Const, Ref] PxArticulationReducedCoordinate articulation, unsigned long index);
    static PxArticulationSpatialTendon PxArticulationReducedCoordinate_getSpatialTendon([Const, Ref] PxArticulationReducedCoordinate articulation, unsigned long index);
    static PxArticulationFixedTendon PxArticulationReducedCoordinate_getFixedTendon([Const, Ref] PxArticulationReducedCoordinate articulation, unsigned long index);
    static PxArticulationAttachment PxArticulationSpatialTendon_getAttachment([Const, Ref] PxArticulationSpatialTendon tendon, unsigned long index);
    static PxRigidActor PxConstraint_getActor0([Const, Ref] PxConstraint constraint);
    static PxRigidActor PxConstraint_getActor1([Const, Ref] PxConstraint constraint);
    [Value] static PxVec3 PxConstraint_getLinearForce([Const, Ref] PxConstraint constraint);
    [Value] static PxVec3 PxConstraint_getAngularForce([Const, Ref] PxConstraint constraint);
    [Value] static PxHullPolygon PxConvexMesh_getPolygon([Const, Ref] PxConvexMesh mesh, unsigned long index);
    static PxRigidActor PxJoint_getActor0([Const, Ref] PxJoint joint);
    static PxRigidActor PxJoint_getActor1([Const, Ref] PxJoint joint);
    static float PxJoint_getBreakForce([Const, Ref] PxJoint joint);
    static float PxJoint_getBreakTorque([Const, Ref] PxJoint joint);
    static PxTriangleMesh PxPhysics_getTriangleMesh([Const, Ref] PxPhysics physics, unsigned long index);
    static PxHeightField PxPhysics_getHeightField([Const, Ref] PxPhysics physics, unsigned long index);
    static PxConvexMesh PxPhysics_getConvexMesh([Const, Ref] PxPhysics physics, unsigned long index);
    static PxScene PxPhysics_getScene([Const, Ref] PxPhysics physics, unsigned long index);
    static PxShape PxPhysics_getShape([Const, Ref] PxPhysics physics, unsigned long index);
    static PxMaterial PxPhysics_getMaterial([Const, Ref] PxPhysics physics, unsigned long index);
    static PxShape PxRigidActor_getShape([Const, Ref] PxRigidActor actor, unsigned long index);
    static PxConstraint PxRigidActor_getConstraint([Const, Ref] PxRigidActor actor, unsigned long index);
    static void PxRigidBody_applyGlobalForce([Ref] PxRigidBody body, [Const, Ref] PxVec3 force, PxForceModeEnum mode, [Const, Ref] PxVec3 point);
    static void PxRigidBody_applyLocalForce([Ref] PxRigidBody body, [Const, Ref] PxVec3 force, PxForceModeEnum mode, [Const, Ref] PxVec3 point);
    [Value] static PxTransform PxRigidDynamic_getKinematicTarget([Const, Ref] PxRigidDynamic actor);
    static PxActor PxScene_getActor([Const, Ref] PxScene scene, [Ref] PxActorTypeFlags types, unsigned long index);
    static PxArticulationReducedCoordinate PxScene_getArticulation([Const, Ref] PxScene scene, unsigned long index);
    static PxConstraint PxScene_getConstraint([Const, Ref] PxScene scene, unsigned long index);
    static void PxShape_setMaterial([Ref] PxShape shape, [Const, Ref] PxMaterial material);
    static PxMaterial PxShape_getMaterial([Const, Ref] PxShape shape, unsigned long index);
};

[Prefix="physx::", NoDelete]
interface PxActor {
    PxActorTypeEnum getType();
    PxScene getScene();
    void setName([Const] DOMString name);
    [Const] DOMString getName();
    [Value] PxBounds3 getWorldBounds(optional float inflation);
    void setActorFlag(PxActorFlagEnum flag, boolean value);
    void setActorFlags([Ref] PxActorFlags flags);
    [Value] PxActorFlags getActorFlags();
    attribute VoidPtr userData;
};
PxActor implements PxBase;

[Prefix="physx::"]
interface PxActorFlag {
};

enum PxActorFlagEnum {
    "PxActorFlag::eVISUALIZATION",
    "PxActorFlag::eDISABLE_GRAVITY",
    "PxActorFlag::eSEND_SLEEP_NOTIFIES",
    "PxActorFlag::eDISABLE_SIMULATION",
};

[Prefix="physx::"]
interface PxActorFlags {
    void PxActorFlags(octet flags);
    void clear(PxActorFlagEnum flag);
    void raise(PxActorFlagEnum flag);
    boolean isSet(PxActorFlagEnum flag);
    [Ref] PxActorFlags setAll(PxActorFlagEnum flag);
};

interface PxActorPtr {
};

[Prefix="physx::"]
interface PxActorShape {
    attribute PxRigidActor actor;
    attribute PxShape shape;
};

[Prefix="physx::"]
interface PxActorType {
};

enum PxActorTypeEnum {
    "PxActorType::eRIGID_STATIC",
    "PxActorType::eRIGID_DYNAMIC",
    "PxActorType::eARTICULATION_LINK",
};

[Prefix="physx::"]
interface PxActorTypeFlag {
};

enum PxActorTypeFlagEnum {
    "PxActorTypeFlag::eRIGID_STATIC",
    "PxActorTypeFlag::eRIGID_DYNAMIC",
};

[Prefix="physx::"]
interface PxActorTypeFlags {
    void PxActorTypeFlags(unsigned short flags);
    void clear(PxActorTypeFlagEnum flag);
    void raise(PxActorTypeFlagEnum flag);
    boolean isSet(PxActorTypeFlagEnum flag);
    [Ref] PxActorTypeFlags setAll(PxActorTypeFlagEnum flag);
};

[Prefix="physx::"]
interface PxAllocatorCallback {
};

[Prefix="physx::"]
interface PxArticulationAttachment {
    void setRestLength(float restLength);
    float getRestLength();
    void setLimitParameters([Const, Ref] PxArticulationTendonLimit parameters);
    [Value] PxArticulationTendonLimit getLimitParameters();
    void setRelativeOffset([Const, Ref] PxVec3 offset);
    [Value] PxVec3 getRelativeOffset();
    void setCoefficient(float coefficient);
    float getCoefficient();
    PxArticulationLink getLink();
    PxArticulationAttachment getParent();
    boolean isLeaf();
    PxArticulationSpatialTendon getTendon();
    attribute VoidPtr userData;
};
PxArticulationAttachment implements PxBase;

[Prefix="physx::"]
interface PxArticulationAxis {
};

enum PxArticulationAxisEnum {
    "PxArticulationAxis::eTWIST",
    "PxArticulationAxis::eSWING1",
    "PxArticulationAxis::eSWING2",
    "PxArticulationAxis::eX",
    "PxArticulationAxis::eY",
    "PxArticulationAxis::eZ",
};

[Prefix="physx::"]
interface PxArticulationDrive {
    void PxArticulationDrive();
    void PxArticulationDrive(float stiffness, float damping, float maxForce, optional PxArticulationDriveTypeEnum driveType);
    attribute float stiffness;
    attribute float damping;
    attribute float maxForce;
    attribute PxArticulationDriveTypeEnum driveType;
};

[Prefix="physx::"]
interface PxArticulationDriveType {
};

enum PxArticulationDriveTypeEnum {
    "PxArticulationDriveType::eFORCE",
    "PxArticulationDriveType::eACCELERATION",
    "PxArticulationDriveType::eNONE",
};

[Prefix="physx::"]
interface PxArticulationFixedTendon {
    PxArticulationTendonJoint createTendonJoint(PxArticulationTendonJoint parent, PxArticulationAxisEnum axis, float coefficient, float recipCoefficient, PxArticulationLink link);
    unsigned long getNbTendonJoints();
    void setRestLength(float restLength);
    float getRestLength();
    void setLimitParameters([Const, Ref] PxArticulationTendonLimit parameter);
    [Value] PxArticulationTendonLimit getLimitParameters();
};
PxArticulationFixedTendon implements PxArticulationTendon;

[Prefix="physx::"]
interface PxArticulationFlag {
};

enum PxArticulationFlagEnum {
    "PxArticulationFlag::eFIX_BASE",
    "PxArticulationFlag::eDRIVE_LIMITS_ARE_FORCES",
    "PxArticulationFlag::eDISABLE_SELF_COLLISION",
};

[Prefix="physx::"]
interface PxArticulationFlags {
    void PxArticulationFlags(octet flags);
    void clear(PxArticulationFlagEnum flag);
    void raise(PxArticulationFlagEnum flag);
    boolean isSet(PxArticulationFlagEnum flag);
    [Ref] PxArticulationFlags setAll(PxArticulationFlagEnum flag);
};

[Prefix="physx::"]
interface PxArticulationJointReducedCoordinate {
    [Ref] PxArticulationLink getParentArticulationLink();
    void setParentPose([Const, Ref] PxTransform pose);
    [Value] PxTransform getParentPose();
    [Ref] PxArticulationLink getChildArticulationLink();
    void setChildPose([Const, Ref] PxTransform pose);
    [Value] PxTransform getChildPose();
    void setJointType(PxArticulationJointTypeEnum jointType);
    PxArticulationJointTypeEnum getJointType();
    void setMotion(PxArticulationAxisEnum axis, PxArticulationMotionEnum motion);
    PxArticulationMotionEnum getMotion(PxArticulationAxisEnum axis);
    void setLimitParams(PxArticulationAxisEnum axis, [Const, Ref] PxArticulationLimit limit);
    [Value] PxArticulationLimit getLimitParams(PxArticulationAxisEnum axis);
    void setDriveParams(PxArticulationAxisEnum axis, [Const, Ref] PxArticulationDrive drive);
    [Value] PxArticulationDrive getDriveParams(PxArticulationAxisEnum axis);
    void setDriveTarget(PxArticulationAxisEnum axis, float target, optional boolean autowake);
    float getDriveTarget(PxArticulationAxisEnum axis);
    void setDriveVelocity(PxArticulationAxisEnum axis, float targetVel, optional boolean autowake);
    float getDriveVelocity(PxArticulationAxisEnum axis);
    void setArmature(PxArticulationAxisEnum axis, float armature);
    float getArmature(PxArticulationAxisEnum axis);
    void setFrictionCoefficient(float coefficient);
    float getFrictionCoefficient();
    void setMaxJointVelocity(float maxJointV);
    float getMaxJointVelocity();
    void setJointPosition(PxArticulationAxisEnum axis, float jointPos);
    float getJointPosition(PxArticulationAxisEnum axis);
    void setJointVelocity(PxArticulationAxisEnum axis, float jointVel);
    float getJointVelocity(PxArticulationAxisEnum axis);
    attribute VoidPtr userData;
};
PxArticulationJointReducedCoordinate implements PxBase;

[Prefix="physx::"]
interface PxArticulationJointType {
};

enum PxArticulationJointTypeEnum {
    "PxArticulationJointType::eFIX",
    "PxArticulationJointType::ePRISMATIC",
    "PxArticulationJointType::eREVOLUTE",
    "PxArticulationJointType::eREVOLUTE_UNWRAPPED",
    "PxArticulationJointType::eSPHERICAL",
    "PxArticulationJointType::eUNDEFINED",
};

[Prefix="physx::"]
interface PxArticulationKinematicFlag {
};

enum PxArticulationKinematicFlagEnum {
    "PxArticulationKinematicFlag::ePOSITION",
    "PxArticulationKinematicFlag::eVELOCITY",
};

[Prefix="physx::"]
interface PxArticulationKinematicFlags {
    void PxArticulationKinematicFlags(octet flags);
    void clear(PxArticulationKinematicFlagEnum flag);
    void raise(PxArticulationKinematicFlagEnum flag);
    boolean isSet(PxArticulationKinematicFlagEnum flag);
    [Ref] PxArticulationKinematicFlags setAll(PxArticulationKinematicFlagEnum flag);
};

[Prefix="physx::"]
interface PxArticulationLimit {
    void PxArticulationLimit();
    void PxArticulationLimit(float low, float high);
    attribute float low;
    attribute float high;
};

[Prefix="physx::", NoDelete]
interface PxArticulationLink {
    [Ref] PxArticulationReducedCoordinate getArticulation();
    PxArticulationJointReducedCoordinate getInboundJoint();
    unsigned long getInboundJointDof();
    unsigned long getNbChildren();
    unsigned long getLinkIndex();
    void setCfmScale(float cfm);
    float getCfmScale();
};
PxArticulationLink implements PxRigidBody;

[Prefix="physx::"]
interface PxArticulationMotion {
};

enum PxArticulationMotionEnum {
    "PxArticulationMotion::eLOCKED",
    "PxArticulationMotion::eLIMITED",
    "PxArticulationMotion::eFREE",
};

[Prefix="physx::"]
interface PxArticulationMotions {
    void PxArticulationMotions(octet flags);
    void clear(PxArticulationMotionEnum flag);
    void raise(PxArticulationMotionEnum flag);
    boolean isSet(PxArticulationMotionEnum flag);
    [Ref] PxArticulationMotions setAll(PxArticulationMotionEnum flag);
};

[Prefix="physx::"]
interface PxArticulationReducedCoordinate {
    PxScene getScene();
    boolean isSleeping();
    void setSleepThreshold(float threshold);
    float getSleepThreshold();
    void setStabilizationThreshold(float threshold);
    float getStabilizationThreshold();
    void setWakeCounter(float wakeCounterValue);
    float getWakeCounter();
    void wakeUp();
    void putToSleep();
    PxArticulationLink createLink(PxArticulationLink parent, [Const, Ref] PxTransform pose);
    unsigned long getNbLinks();
    unsigned long getNbShapes();
    void setName([Const] DOMString name);
    [Const] DOMString getName();
    [Value] PxBounds3 getWorldBounds(optional float inflation);
    void setArticulationFlags([Ref] PxArticulationFlags flags);
    void setArticulationFlag(PxArticulationFlagEnum flag, boolean value);
    [Value] PxArticulationFlags getArticulationFlags();
    unsigned long getDofs();
    void setRootGlobalPose([Const, Ref] PxTransform pose, optional boolean autowake);
    [Value] PxTransform getRootGlobalPose();
    void setRootLinearVelocity([Const, Ref] PxVec3 linearVelocity, optional boolean autowake);
    [Value] PxVec3 getRootLinearVelocity();
    void setRootAngularVelocity([Const, Ref] PxVec3 angularVelocity, optional boolean autowake);
    [Value] PxVec3 getRootAngularVelocity();
    [Value] PxSpatialVelocity getLinkAcceleration(unsigned long linkId);
    PxArticulationSpatialTendon createSpatialTendon();
    PxArticulationFixedTendon createFixedTendon();
    unsigned long getNbSpatialTendons();
    unsigned long getNbFixedTendons();
    void updateKinematic([Ref] PxArticulationKinematicFlags flags);
    attribute VoidPtr userData;
};
PxArticulationReducedCoordinate implements PxBase;

[Prefix="physx::"]
interface PxArticulationSpatialTendon {
    PxArticulationAttachment createAttachment(PxArticulationAttachment parent, float coefficient, [Const, Ref] PxVec3 relativeOffset, PxArticulationLink link);
    unsigned long getNbAttachments();
};
PxArticulationSpatialTendon implements PxArticulationTendon;

[Prefix="physx::"]
interface PxArticulationTendon {
    void setStiffness(float stiffness);
    float getStiffness();
    void setDamping(float damping);
    float getDamping();
    void setLimitStiffness(float stiffness);
    float getLimitStiffness();
    void setOffset(float offset, optional boolean autowake);
    float getOffset();
    PxArticulationReducedCoordinate getArticulation();
    attribute VoidPtr userData;
};
PxArticulationTendon implements PxBase;

[Prefix="physx::"]
interface PxArticulationTendonJoint {
    void setCoefficient(PxArticulationAxisEnum axis, float coefficient, float recipCoefficient);
    PxArticulationLink getLink();
    PxArticulationTendonJoint getParent();
    PxArticulationFixedTendon getTendon();
    attribute VoidPtr userData;
};
PxArticulationTendonJoint implements PxBase;

[Prefix="physx::"]
interface PxArticulationTendonLimit {
    void PxArticulationTendonLimit();
    attribute float lowLimit;
    attribute float highLimit;
};

[Prefix="physx::", NoDelete]
interface PxBase {
    void release();
    [Const] DOMString getConcreteTypeName();
};

[Prefix="physx::"]
interface PxBaseMaterial {
    attribute VoidPtr userData;
};
PxBaseMaterial implements PxRefCounted;

[Prefix="physx::"]
interface PxBoundedData {
    attribute unsigned long count;
};
PxBoundedData implements PxStridedData;

[Prefix="physx::"]
interface PxBounds3 {
    [Value] attribute PxVec3 minimum;
    [Value] attribute PxVec3 maximum;
};

[Prefix="physx::", NoDelete]
interface PxBoxController {
    float getHalfHeight();
    float getHalfSideExtent();
    float getHalfForwardExtent();
    boolean setHalfHeight(float halfHeight);
    boolean setHalfSideExtent(float halfSideExtent);
    boolean setHalfForwardExtent(float halfForwardExtent);
};
PxBoxController implements PxController;

[Prefix="physx::"]
interface PxBoxControllerDesc {
    void PxBoxControllerDesc();
    attribute float halfHeight;
    attribute float halfSideExtent;
    attribute float halfForwardExtent;
};
PxBoxControllerDesc implements PxControllerDesc;

[Prefix="physx::"]
interface PxBoxGeometry {
    void PxBoxGeometry();
    void PxBoxGeometry(float hx, float hy, float hz);
    void PxBoxGeometry([Ref] PxVec3 halfExtents);
    [Value] attribute PxVec3 halfExtents;
};
PxBoxGeometry implements PxGeometry;

[Prefix="physx::"]
interface PxCapsuleClimbingMode {
};

enum PxCapsuleClimbingModeEnum {
    "PxCapsuleClimbingMode::eEASY",
    "PxCapsuleClimbingMode::eCONSTRAINED",
    "PxCapsuleClimbingMode::eLAST",
};

[Prefix="physx::", NoDelete]
interface PxCapsuleController {
    float getRadius();
    boolean setRadius(float radius);
    float getHeight();
    boolean setHeight(float height);
    PxCapsuleClimbingModeEnum getClimbingMode();
    boolean setClimbingMode(PxCapsuleClimbingModeEnum mode);
};
PxCapsuleController implements PxController;

[Prefix="physx::"]
interface PxCapsuleControllerDesc {
    void PxCapsuleControllerDesc();
    attribute float radius;
    attribute float height;
    attribute PxCapsuleClimbingModeEnum climbingMode;
};
PxCapsuleControllerDesc implements PxControllerDesc;

[Prefix="physx::"]
interface PxCapsuleGeometry {
    void PxCapsuleGeometry();
    void PxCapsuleGeometry(float radius, float halfHeight);
    attribute float radius;
    attribute float halfHeight;
};
PxCapsuleGeometry implements PxGeometry;

[Prefix="physx::"]
interface PxCombineMode {
};

enum PxCombineModeEnum {
    "PxCombineMode::eAVERAGE",
    "PxCombineMode::eMIN",
    "PxCombineMode::eMULTIPLY",
    "PxCombineMode::eMAX",
};

[Prefix="physx::", NoDelete]
interface PxConstraint {
    PxScene getScene();
    void setActors(PxRigidActor actor0, PxRigidActor actor1);
    void setFlags([Ref] PxConstraintFlags flags);
    void setFlag(PxConstraintFlagEnum flag, boolean value);
    [Value] PxConstraintFlags getFlags();
    void setBreakForce(float linear, float angular);
    void setMinResponseThreshold(float threshold);
    float getMinResponseThreshold();
    attribute VoidPtr userData;
};
PxConstraint implements PxBase;

[Prefix="physx::"]
interface PxConstraintFlag {
};

enum PxConstraintFlagEnum {
    "PxConstraintFlag::eBROKEN",
    "PxConstraintFlag::eCOLLISION_ENABLED",
    "PxConstraintFlag::eVISUALIZATION",
    "PxConstraintFlag::eDRIVE_LIMITS_ARE_FORCES",
    "PxConstraintFlag::eIMPROVED_SLERP",
    "PxConstraintFlag::eDISABLE_PREPROCESSING",
    "PxConstraintFlag::eENABLE_EXTENDED_LIMITS",
    "PxConstraintFlag::eALWAYS_UPDATE",
    "PxConstraintFlag::eDISABLE_CONSTRAINT",
};

[Prefix="physx::"]
interface PxConstraintFlags {
    void PxConstraintFlags(unsigned short flags);
    void clear(PxConstraintFlagEnum flag);
    void raise(PxConstraintFlagEnum flag);
    boolean isSet(PxConstraintFlagEnum flag);
    [Ref] PxConstraintFlags setAll(PxConstraintFlagEnum flag);
};

[Prefix="physx::"]
interface PxConstraintInfo {
    attribute PxConstraint constraint;
    attribute VoidPtr externalReference;
    attribute unsigned long type;
};

[Prefix="physx::"]
interface PxContactPair {
    unsigned long extractContacts(PxContactPairPoint userBuffer, unsigned long bufferSize);
    attribute PxShape[] shapes;
    attribute octet contactCount;
    [Value] attribute PxContactPairFlags flags;
    [Value] attribute PxPairFlags events;
};

[Prefix="physx::"]
interface PxContactPairFlag {
};

enum PxContactPairFlagEnum {
    "PxContactPairFlag::eREMOVED_SHAPE_0",
    "PxContactPairFlag::eREMOVED_SHAPE_1",
    "PxContactPairFlag::eACTOR_PAIR_HAS_FIRST_TOUCH",
    "PxContactPairFlag::eACTOR_PAIR_LOST_TOUCH",
};

[Prefix="physx::"]
interface PxContactPairFlags {
    void PxContactPairFlags(unsigned short flags);
    void clear(PxContactPairFlagEnum flag);
    void raise(PxContactPairFlagEnum flag);
    boolean isSet(PxContactPairFlagEnum flag);
    [Ref] PxContactPairFlags setAll(PxContactPairFlagEnum flag);
};

[Prefix="physx::"]
interface PxContactPairHeader {
    attribute PxActor[] actors;
    [Value] attribute PxContactPairHeaderFlags flags;
    [Const] attribute PxContactPair pairs;
    attribute unsigned long nbPairs;
};

[Prefix="physx::"]
interface PxContactPairHeaderFlag {
};

enum PxContactPairHeaderFlagEnum {
    "PxContactPairHeaderFlag::eREMOVED_ACTOR_0",
    "PxContactPairHeaderFlag::eREMOVED_ACTOR_1",
};

[Prefix="physx::"]
interface PxContactPairHeaderFlags {
    void PxContactPairHeaderFlags(unsigned short flags);
    void clear(PxContactPairHeaderFlagEnum flag);
    void raise(PxContactPairHeaderFlagEnum flag);
    boolean isSet(PxContactPairHeaderFlagEnum flag);
    [Ref] PxContactPairHeaderFlags setAll(PxContactPairHeaderFlagEnum flag);
};

[Prefix="physx::"]
interface PxContactPairPoint {
    [Value] attribute PxVec3 position;
    [Value] attribute PxVec3 normal;
    [Value] attribute PxVec3 impulse;
    attribute float separation;
};

[Prefix="physx::", NoDelete]
interface PxController {
    PxControllerShapeTypeEnum getType();
    void release();
    // [Value] PxControllerCollisionFlags move([Const, Ref] PxVec3 disp, float minDist, float elapsedTime, [Const, Ref] PxControllerFilters filters, [Const] optional PxObstacleContext obstacles);
    boolean setPosition([Const, Ref] PxExtendedVec3 position);
    [Const, Ref] PxExtendedVec3 getPosition();
    boolean setFootPosition([Const, Ref] PxExtendedVec3 position);
    [Value] PxExtendedVec3 getFootPosition();
    PxRigidDynamic getActor();
    void setStepOffset(float offset);
    float getStepOffset();
    void setNonWalkableMode(PxControllerNonWalkableModeEnum flag);
    PxControllerNonWalkableModeEnum getNonWalkableMode();
    float getContactOffset();
    void setContactOffset(float offset);
    [Value] PxVec3 getUpDirection();
    void setUpDirection([Const, Ref] PxVec3 up);
    float getSlopeLimit();
    void setSlopeLimit(float slopeLimit);
    void invalidateCache();
    PxScene getScene();
    VoidPtr getUserData();
    void setUserData(VoidPtr userData);
    void resize(float height);
};

[Prefix="physx::"]
interface PxControllerDebugRenderFlag {
};

enum PxControllerDebugRenderFlagEnum {
    "PxControllerDebugRenderFlag::eTEMPORAL_BV",
    "PxControllerDebugRenderFlag::eCACHED_BV",
    "PxControllerDebugRenderFlag::eOBSTACLES",
    "PxControllerDebugRenderFlag::eNONE",
    "PxControllerDebugRenderFlag::eALL",
};

[Prefix="physx::"]
interface PxControllerDebugRenderFlags {
    void PxControllerDebugRenderFlags(unsigned long flags);
    void clear(PxControllerDebugRenderFlagEnum flag);
    void raise(PxControllerDebugRenderFlagEnum flag);
    boolean isSet(PxControllerDebugRenderFlagEnum flag);
    [Ref] PxControllerDebugRenderFlags setAll(PxControllerDebugRenderFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxControllerDesc {
    PxControllerShapeTypeEnum getType();
    [Value] attribute PxExtendedVec3 position;
    [Value] attribute PxVec3 upDirection;
    attribute float slopeLimit;
    attribute float invisibleWallHeight;
    attribute float maxJumpHeight;
    attribute float contactOffset;
    attribute float stepOffset;
    attribute float density;
    attribute float scaleCoeff;
    attribute float volumeGrowth;
    // attribute PxUserControllerHitReport reportCallback;
    // attribute PxControllerBehaviorCallback behaviorCallback;
    attribute PxControllerNonWalkableModeEnum nonWalkableMode;
    attribute PxMaterial material;
    attribute boolean registerDeletionListener;
    attribute VoidPtr userData;
};

[Prefix="physx::", NoDelete]
interface PxControllerManager {
    void release();
    [Ref] PxScene getScene();
    unsigned long getNbControllers();
    PxController getController(unsigned long index);
    PxController createController([Const, Ref] PxControllerDesc desc);
    void purgeControllers();
    [Const, Ref] PxRenderBuffer getRenderBuffer();
    void setDebugRenderingFlags([Ref] PxControllerDebugRenderFlags flags);
    // unsigned long getNbObstacleContexts();
    // PxObstacleContext getObstacleContext(unsigned long index);
    // PxObstacleContext createObstacleContext();
    void computeInteractions(float elapsedTime);
    void setTessellation(boolean flag, float maxEdgeLength);
    void setOverlapRecoveryModule(boolean flag);
    void setPreciseSweeps(boolean flags);
    void setPreventVerticalSlidingAgainstCeiling(boolean flag);
    void shiftOrigin([Const, Ref] PxVec3 shift);
};

[Prefix="physx::"]
interface PxControllerNonWalkableMode {
};

enum PxControllerNonWalkableModeEnum {
    "PxControllerNonWalkableMode::ePREVENT_CLIMBING",
    "PxControllerNonWalkableMode::ePREVENT_CLIMBING_AND_FORCE_SLIDING",
};

[Prefix="physx::"]
interface PxControllerShapeType {
};

enum PxControllerShapeTypeEnum {
    "PxControllerShapeType::eBOX",
    "PxControllerShapeType::eCAPSULE",
};

[Prefix="physx::"]
interface PxConvexFlag {
};

enum PxConvexFlagEnum {
    "PxConvexFlag::e16_BIT_INDICES",
    "PxConvexFlag::eCOMPUTE_CONVEX",
    "PxConvexFlag::eCHECK_ZERO_AREA_TRIANGLES",
    "PxConvexFlag::eQUANTIZE_INPUT",
    "PxConvexFlag::eDISABLE_MESH_VALIDATION",
    "PxConvexFlag::ePLANE_SHIFTING",
    "PxConvexFlag::eFAST_INERTIA_COMPUTATION",
    "PxConvexFlag::eSHIFT_VERTICES",
};

[Prefix="physx::"]
interface PxConvexFlags {
    void PxConvexFlags(unsigned short flags);
    void clear(PxConvexFlagEnum flag);
    void raise(PxConvexFlagEnum flag);
    boolean isSet(PxConvexFlagEnum flag);
    [Ref] PxConvexFlags setAll(PxConvexFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxConvexMesh {
    unsigned long getNbVertices();
    [Const] PxVec3 getVertices();
    unsigned long getNbPolygons();
    [Value] PxBounds3 getLocalBounds();
};
PxConvexMesh implements PxRefCounted;

[Prefix="physx::"]
interface PxConvexMeshCookingType {
};

enum PxConvexMeshCookingTypeEnum {
    "PxConvexMeshCookingType::eQUICKHULL",
};

[Prefix="physx::"]
interface PxConvexMeshDesc {
    void PxConvexMeshDesc();
    [Value] attribute PxBoundedData points;
    [Value] attribute PxBoundedData polygons;
    [Value] attribute PxBoundedData indices;
    [Value] attribute PxConvexFlags flags;
};

[Prefix="physx::"]
interface PxConvexMeshGeometry {
    void PxConvexMeshGeometry(optional PxConvexMesh mesh, [Const, Ref] optional PxMeshScale scaling, [Ref] optional PxConvexMeshGeometryFlags flags);
    [Value] attribute PxMeshScale scale;
    [Value] attribute PxConvexMeshGeometryFlags meshFlags;
    attribute PxConvexMesh convexMesh;
};
PxConvexMeshGeometry implements PxGeometry;

[Prefix="physx::"]
interface PxConvexMeshGeometryFlag {
};

enum PxConvexMeshGeometryFlagEnum {
    "PxConvexMeshGeometryFlag::eTIGHT_BOUNDS",
};

[Prefix="physx::"]
interface PxConvexMeshGeometryFlags {
    void PxConvexMeshGeometryFlags(octet flags);
    void clear(PxConvexMeshGeometryFlagEnum flag);
    void raise(PxConvexMeshGeometryFlagEnum flag);
    boolean isSet(PxConvexMeshGeometryFlagEnum flag);
    [Ref] PxConvexMeshGeometryFlags setAll(PxConvexMeshGeometryFlagEnum flag);
};

[Prefix="physx::"]
interface PxCookingParams {
    void PxCookingParams([Const, Ref] PxTolerancesScale sc);
    attribute float areaTestEpsilon;
    attribute float planeTolerance;
    attribute PxConvexMeshCookingTypeEnum convexMeshCookingType;
    attribute boolean suppressTriangleMeshRemapTable;
    attribute boolean buildTriangleAdjacencies;
    attribute boolean buildGPUData;
    [Value] attribute PxTolerancesScale scale;
    [Value] attribute PxMeshPreprocessingFlags meshPreprocessParams;
    attribute float meshWeldTolerance;
    [Value] attribute PxMidphaseDesc midphaseDesc;
    attribute unsigned long gaussMapLimit;
};

[Prefix="physx::"]
interface PxCpuDispatcher {
};

[Prefix="physx::"]
interface PxCustomGeometry {
    void PxCustomGeometry();
    void PxCustomGeometry([Ref] PxCustomGeometryCallbacks callbacks);
    attribute PxCustomGeometryCallbacks callbacks;
};
PxCustomGeometry implements PxGeometry;

interface PxCustomGeometryCallbacks {
};

[Prefix="physx::"]
interface PxCustomGeometryExtConeCallbacks {
    void PxCustomGeometryExtConeCallbacks(float height, float radius, optional long axis);
    void setHeight(float height);
    float getHeight();
    void setRadius(float radius);
    float getRadius();
    void setAxis(long axis);
    long getAxis();
};
PxCustomGeometryExtConeCallbacks implements PxCustomGeometryCallbacks;

[Prefix="physx::"]
interface PxCustomGeometryExtCylinderCallbacks {
    void PxCustomGeometryExtCylinderCallbacks(float height, float radius, optional long axis);
    void setHeight(float height);
    float getHeight();
    void setRadius(float radius);
    float getRadius();
    void setAxis(long axis);
    long getAxis();
};
PxCustomGeometryExtCylinderCallbacks implements PxCustomGeometryCallbacks;

[Prefix="physx::"]
interface PxD6Axis {
};

enum PxD6AxisEnum {
    "PxD6Axis::eX",
    "PxD6Axis::eY",
    "PxD6Axis::eZ",
    "PxD6Axis::eTWIST",
    "PxD6Axis::eSWING1",
    "PxD6Axis::eSWING2",
};

[Prefix="physx::"]
interface PxD6Drive {
};

enum PxD6DriveEnum {
    "PxD6Drive::eX",
    "PxD6Drive::eY",
    "PxD6Drive::eZ",
    "PxD6Drive::eSWING",
    "PxD6Drive::eTWIST",
    "PxD6Drive::eSLERP",
};

[Prefix="physx::"]
interface PxD6Joint {
    void setMotion(PxD6AxisEnum axis, PxD6MotionEnum type);
    PxD6MotionEnum getMotion(PxD6AxisEnum axis);
    float getTwistAngle();
    float getSwingYAngle();
    float getSwingZAngle();
    void setDistanceLimit([Const, Ref] PxJointLinearLimit limit);
    // [Value] PxJointLinearLimit getDistanceLimit();
    void setLinearLimit(PxD6AxisEnum axis, [Const, Ref] PxJointLinearLimitPair limit);
    // [Value] PxJointLinearLimitPair getLinearLimit(PxD6AxisEnum axis);
    void setTwistLimit([Const, Ref] PxJointAngularLimitPair limit);
    // [Value] PxJointAngularLimitPair getTwistLimit();
    void setSwingLimit([Const, Ref] PxJointLimitCone limit);
    // [Value] PxJointLimitCone getSwingLimit();
    void setPyramidSwingLimit([Const, Ref] PxJointLimitPyramid limit);
    // [Value] PxJointLimitPyramid getPyramidSwingLimit();
    void setDrive(PxD6DriveEnum index, [Const, Ref] PxD6JointDrive drive);
    [Value] PxD6JointDrive getDrive(PxD6DriveEnum index);
    void setDrivePosition([Const, Ref] PxTransform pose, optional boolean autowake);
    [Value] PxTransform getDrivePosition();
    void setDriveVelocity([Const, Ref] PxVec3 linear, [Const, Ref] PxVec3 angular);
    void getDriveVelocity([Ref] PxVec3 linear, [Ref] PxVec3 angular);
};
PxD6Joint implements PxJoint;

[Prefix="physx::"]
interface PxD6JointDrive {
    void PxD6JointDrive();
    void PxD6JointDrive(float driveStiffness, float driveDamping, float driveForceLimit, optional boolean isAcceleration);
    attribute float forceLimit;
    [Value] attribute PxD6JointDriveFlags flags;
};
PxD6JointDrive implements PxSpring;

[Prefix="physx::"]
interface PxD6JointDriveFlag {
};

enum PxD6JointDriveFlagEnum {
    "PxD6JointDriveFlag::eACCELERATION",
};

[Prefix="physx::"]
interface PxD6JointDriveFlags {
    void PxD6JointDriveFlags(unsigned long flags);
    void clear(PxD6JointDriveFlagEnum flag);
    void raise(PxD6JointDriveFlagEnum flag);
    boolean isSet(PxD6JointDriveFlagEnum flag);
    [Ref] PxD6JointDriveFlags setAll(PxD6JointDriveFlagEnum flag);
};

[Prefix="physx::"]
interface PxD6Motion {
};

enum PxD6MotionEnum {
    "PxD6Motion::eLOCKED",
    "PxD6Motion::eLIMITED",
    "PxD6Motion::eFREE",
};

[Prefix="physx::"]
interface PxDebugColor {
};

enum PxDebugColorEnum {
    "PxDebugColor::eARGB_BLACK",
    "PxDebugColor::eARGB_RED",
    "PxDebugColor::eARGB_GREEN",
    "PxDebugColor::eARGB_BLUE",
    "PxDebugColor::eARGB_YELLOW",
    "PxDebugColor::eARGB_MAGENTA",
    "PxDebugColor::eARGB_CYAN",
    "PxDebugColor::eARGB_WHITE",
    "PxDebugColor::eARGB_GREY",
    "PxDebugColor::eARGB_DARKRED",
    "PxDebugColor::eARGB_DARKGREEN",
    "PxDebugColor::eARGB_DARKBLUE",
};

[Prefix="physx::", NoDelete]
interface PxDebugLine {
    [Value] attribute PxVec3 pos0;
    attribute unsigned long color0;
    [Value] attribute PxVec3 pos1;
    attribute unsigned long color1;
};

[Prefix="physx::", NoDelete]
interface PxDebugPoint {
    [Value] attribute PxVec3 pos;
    attribute unsigned long color;
};

[Prefix="physx::", NoDelete]
interface PxDebugTriangle {
    [Value] attribute PxVec3 pos0;
    attribute unsigned long color0;
    [Value] attribute PxVec3 pos1;
    attribute unsigned long color1;
    [Value] attribute PxVec3 pos2;
    attribute unsigned long color2;
};

[Prefix="physx::"]
interface PxDefaultAllocator {
    void PxDefaultAllocator();
};
PxDefaultAllocator implements PxAllocatorCallback;

[Prefix="physx::"]
interface PxDefaultCpuDispatcher {
};
PxDefaultCpuDispatcher implements PxCpuDispatcher;

[Prefix="physx::"]
interface PxDefaultErrorCallback {
    void PxDefaultErrorCallback();
};
PxDefaultErrorCallback implements PxErrorCallback;

[Prefix="physx::"]
interface PxDistanceJoint {
    float getDistance();
    void setMinDistance(float distance);
    float getMinDistance();
    void setMaxDistance(float distance);
    float getMaxDistance();
    void setTolerance(float tolerance);
    float getTolerance();
    void setStiffness(float stiffness);
    float getStiffness();
    void setDamping(float damping);
    float getDamping();
    void setDistanceJointFlags([Ref] PxDistanceJointFlags flags);
    void setDistanceJointFlag(PxDistanceJointFlagEnum flag, boolean value);
    [Value] PxDistanceJointFlags getDistanceJointFlags();
};
PxDistanceJoint implements PxJoint;

[Prefix="physx::"]
interface PxDistanceJointFlag {
};

enum PxDistanceJointFlagEnum {
    "PxDistanceJointFlag::eMAX_DISTANCE_ENABLED",
    "PxDistanceJointFlag::eMIN_DISTANCE_ENABLED",
    "PxDistanceJointFlag::eSPRING_ENABLED",
};

[Prefix="physx::"]
interface PxDistanceJointFlags {
    void PxDistanceJointFlags(unsigned short flags);
    void clear(PxDistanceJointFlagEnum flag);
    void raise(PxDistanceJointFlagEnum flag);
    boolean isSet(PxDistanceJointFlagEnum flag);
    [Ref] PxDistanceJointFlags setAll(PxDistanceJointFlagEnum flag);
};

[Prefix="physx::"]
interface PxEMPTY {
};

enum PxEMPTYEnum {
    "PxEMPTY::PxEmpty",
};

[Prefix="physx::"]
interface PxErrorCallback {
};

[Prefix="physx::"]
interface PxExtendedVec3 {
    void PxExtendedVec3();
    void PxExtendedVec3(PxZEROEnum zero);
    void PxExtendedVec3(double x, double y, double z);
    boolean isZero();
    boolean isFinite();
    boolean isNormalized();
    double magnitudeSquared();
    double magnitude();
    double dot([Const, Ref] PxExtendedVec3 v);
    [Value] PxExtendedVec3 cross([Const, Ref] PxExtendedVec3 v);
    [Value] PxExtendedVec3 getNormalized();
    double normalize();
    double normalizeSafe();
    double normalizeFast();
    [Value] PxExtendedVec3 multiply([Const, Ref] PxExtendedVec3 a);
    [Value] PxExtendedVec3 minimum([Const, Ref] PxExtendedVec3 v);
    double minElement();
    [Value] PxExtendedVec3 maximum([Const, Ref] PxExtendedVec3 v);
    double maxElement();
    [Value] PxExtendedVec3 abs();
    attribute double x;
    attribute double y;
    attribute double z;
};

[Prefix="physx::"]
interface PxFilterData {
    void PxFilterData();
    void PxFilterData(PxEMPTYEnum empty);
    void PxFilterData(unsigned long w0, unsigned long w1, unsigned long w2, unsigned long w3);
    attribute unsigned long word0;
    attribute unsigned long word1;
    attribute unsigned long word2;
    attribute unsigned long word3;
};

[Prefix="physx::"]
interface PxFilterFlag {
};

enum PxFilterFlagEnum {
    "PxFilterFlag::eKILL",
    "PxFilterFlag::eSUPPRESS",
    "PxFilterFlag::eCALLBACK",
    "PxFilterFlag::eNOTIFY",
    "PxFilterFlag::eDEFAULT",
};

[Prefix="physx::"]
interface PxFilterFlags {
    void PxFilterFlags(unsigned short flags);
    void clear(PxFilterFlagEnum flag);
    void raise(PxFilterFlagEnum flag);
    boolean isSet(PxFilterFlagEnum flag);
    [Ref] PxFilterFlags setAll(PxFilterFlagEnum flag);
};

[Prefix="physx::"]
interface PxFilterObjectFlag {
};

enum PxFilterObjectFlagEnum {
    "PxFilterObjectFlag::eKINEMATIC",
    "PxFilterObjectFlag::eTRIGGER",
};

[Prefix="physx::"]
interface PxFilterObjectType {
};

enum PxFilterObjectTypeEnum {
    "PxFilterObjectType::eRIGID_STATIC",
    "PxFilterObjectType::eRIGID_DYNAMIC",
    "PxFilterObjectType::eARTICULATION",
};

[Prefix="physx::"]
interface PxFixedJoint {
};
PxFixedJoint implements PxJoint;

[Prefix="physx::"]
interface PxForceMode {
};

enum PxForceModeEnum {
    "PxForceMode::eFORCE",
    "PxForceMode::eIMPULSE",
    "PxForceMode::eVELOCITY_CHANGE",
    "PxForceMode::eACCELERATION",
};

[Prefix="physx::", NoDelete]
interface PxFoundation {
    void release();
};

[Prefix="physx::"]
interface PxFrictionType {
};

enum PxFrictionTypeEnum {
    "PxFrictionType::ePATCH",
    "PxFrictionType::eFRICTION_COUNT",
};

[Prefix="physx::"]
interface PxGeometry {
    PxGeometryTypeEnum getType();
};

[Prefix="physx::"]
interface PxGeometryType {
};

enum PxGeometryTypeEnum {
    "PxGeometryType::eSPHERE",
    "PxGeometryType::ePLANE",
    "PxGeometryType::eCAPSULE",
    "PxGeometryType::eBOX",
    "PxGeometryType::eCONVEXMESH",
    "PxGeometryType::eTRIANGLEMESH",
    "PxGeometryType::eHEIGHTFIELD",
    "PxGeometryType::eCUSTOM",
};

[Prefix="physx::"]
interface PxGeomOverlapHit {
};
PxGeomOverlapHit implements PxQueryHit;

[Prefix="physx::"]
interface PxGeomRaycastHit {
    attribute float u;
    attribute float v;
};
PxGeomRaycastHit implements PxLocationHit;

[Prefix="physx::"]
interface PxGeomSweepHit {
};
PxGeomSweepHit implements PxLocationHit;

[Prefix="physx::", NoDelete]
interface PxHeightField {
    unsigned long saveCells(VoidPtr destBuffer, unsigned long destBufferSize);
    boolean modifySamples(long startCol, long startRow, [Const, Ref] PxHeightFieldDesc subfieldDesc, optional boolean shrinkBounds);
    unsigned long getNbRows();
    unsigned long getNbColumns();
    PxHeightFieldFormatEnum getFormat();
    unsigned long getSampleStride();
    float getConvexEdgeThreshold();
    [Value] PxHeightFieldFlags getFlags();
    float getHeight(float x, float z);
    [Const, Ref] PxHeightFieldSample getSample(unsigned long row, unsigned long column);
};
PxHeightField implements PxRefCounted;

[Prefix="physx::"]
interface PxHeightFieldDesc {
    void PxHeightFieldDesc();
    attribute unsigned long nbRows;
    attribute unsigned long nbColumns;
    attribute PxHeightFieldFormatEnum format;
    [Value] attribute PxStridedData samples;
    attribute float convexEdgeThreshold;
    [Value] attribute PxHeightFieldFlags flags;
};

[Prefix="physx::"]
interface PxHeightFieldFlag {
};

enum PxHeightFieldFlagEnum {
    "PxHeightFieldFlag::eNO_BOUNDARY_EDGES",
};

[Prefix="physx::"]
interface PxHeightFieldFlags {
    void PxHeightFieldFlags(unsigned short flags);
    void clear(PxHeightFieldFlagEnum flag);
    void raise(PxHeightFieldFlagEnum flag);
    boolean isSet(PxHeightFieldFlagEnum flag);
    [Ref] PxHeightFieldFlags setAll(PxHeightFieldFlagEnum flag);
};

[Prefix="physx::"]
interface PxHeightFieldFormat {
};

enum PxHeightFieldFormatEnum {
    "PxHeightFieldFormat::eS16_TM",
};

[Prefix="physx::"]
interface PxHeightFieldGeometry {
    void PxHeightFieldGeometry(optional PxHeightField hf, [Ref] optional PxMeshGeometryFlags flags, optional float heightScale, optional float rowScale, optional float columnScale);
    attribute PxHeightField heightField;
    attribute float heightScale;
    attribute float rowScale;
    attribute float columnScale;
    [Value] attribute PxMeshGeometryFlags heightFieldFlags;
};
PxHeightFieldGeometry implements PxGeometry;

[Prefix="physx::"]
interface PxHeightFieldSample {
    void PxHeightFieldSample();
    octet tessFlag();
    void clearTessFlag();
    void setTessFlag();
    attribute short height;
};

[Prefix="physx::"]
interface PxHitFlag {
};

enum PxHitFlagEnum {
    "PxHitFlag::ePOSITION",
    "PxHitFlag::eNORMAL",
    "PxHitFlag::eUV",
    "PxHitFlag::eASSUME_NO_INITIAL_OVERLAP",
    "PxHitFlag::eANY_HIT",
    "PxHitFlag::eMESH_MULTIPLE",
    "PxHitFlag::eMESH_BOTH_SIDES",
    "PxHitFlag::ePRECISE_SWEEP",
    "PxHitFlag::eMTD",
    "PxHitFlag::eFACE_INDEX",
    "PxHitFlag::eDEFAULT",
    "PxHitFlag::eMODIFIABLE_FLAGS",
};

[Prefix="physx::"]
interface PxHitFlags {
    void PxHitFlags(unsigned short flags);
    void clear(PxHitFlagEnum flag);
    void raise(PxHitFlagEnum flag);
    boolean isSet(PxHitFlagEnum flag);
    [Ref] PxHitFlags setAll(PxHitFlagEnum flag);
};

[Prefix="physx::"]
interface PxHullPolygon {
    attribute float[] mPlane;
    attribute short mNbVerts;
    attribute short mIndexBase;
};

[Prefix="physx::"]
interface PxIDENTITY {
};

enum PxIDENTITYEnum {
    "PxIDENTITY::PxIdentity",
};

[Prefix="physx::", NoDelete]
interface PxInsertionCallback {
};

[Prefix="physx::", NoDelete]
interface PxJoint {
    void setActors(PxRigidActor actor0, PxRigidActor actor1);
    void setLocalPose(PxJointActorIndexEnum actor, [Const, Ref] PxTransform localPose);
    [Value] PxTransform getLocalPose(PxJointActorIndexEnum actor);
    [Value] PxTransform getRelativeTransform();
    [Value] PxVec3 getRelativeLinearVelocity();
    [Value] PxVec3 getRelativeAngularVelocity();
    void setBreakForce(float force, float torque);
    void setConstraintFlags([Ref] PxConstraintFlags flags);
    void setConstraintFlag(PxConstraintFlagEnum flag, boolean value);
    [Value] PxConstraintFlags getConstraintFlags();
    void setInvMassScale0(float invMassScale);
    float getInvMassScale0();
    void setInvInertiaScale0(float invInertiaScale);
    float getInvInertiaScale0();
    void setInvMassScale1(float invMassScale);
    float getInvMassScale1();
    void setInvInertiaScale1(float invInertiaScale);
    float getInvInertiaScale1();
    PxConstraint getConstraint();
    void setName([Const] DOMString name);
    [Const] DOMString getName();
    PxScene getScene();
    attribute VoidPtr userData;
};
PxJoint implements PxBase;

[Prefix="physx::"]
interface PxJointActorIndex {
};

enum PxJointActorIndexEnum {
    "PxJointActorIndex::eACTOR0",
    "PxJointActorIndex::eACTOR1",
};

[Prefix="physx::"]
interface PxJointAngularLimitPair {
    void PxJointAngularLimitPair(float lowerLimit, float upperLimit);
    void PxJointAngularLimitPair(float lowerLimit, float upperLimit, [Const, Ref] PxSpring spring);
    attribute float upper;
    attribute float lower;
};
PxJointAngularLimitPair implements PxJointLimitParameters;

[Prefix="physx::"]
interface PxJointLimitCone {
    void PxJointLimitCone(float yLimitAngle, float zLimitAngle);
    void PxJointLimitCone(float yLimitAngle, float zLimitAngle, [Const, Ref] PxSpring spring);
    attribute float yAngle;
    attribute float zAngle;
};
PxJointLimitCone implements PxJointLimitParameters;

[Prefix="physx::", NoDelete]
interface PxJointLimitParameters {
    boolean isSoft();
    attribute float restitution;
    attribute float bounceThreshold;
    attribute float stiffness;
    attribute float damping;
};

[Prefix="physx::"]
interface PxJointLimitPyramid {
    void PxJointLimitPyramid(float yLimitAngleMin, float yLimitAngleMax, float zLimitAngleMin, float zLimitAngleMax);
    void PxJointLimitPyramid(float yLimitAngleMin, float yLimitAngleMax, float zLimitAngleMin, float zLimitAngleMax, [Const, Ref] PxSpring spring);
    attribute float yAngleMin;
    attribute float yAngleMax;
    attribute float zAngleMin;
    attribute float zAngleMax;
};
PxJointLimitPyramid implements PxJointLimitParameters;

[Prefix="physx::"]
interface PxJointLinearLimit {
    void PxJointLinearLimit(float extent, [Const, Ref] PxSpring spring);
    attribute float value;
};
PxJointLinearLimit implements PxJointLimitParameters;

[Prefix="physx::"]
interface PxJointLinearLimitPair {
    void PxJointLinearLimitPair(float lowerLimit, float upperLimit, [Const, Ref] PxSpring spring);
    attribute float upper;
    attribute float lower;
};
PxJointLinearLimitPair implements PxJointLimitParameters;

[Prefix="physx::"]
interface PxLocationHit {
    boolean hadInitialOverlap();
    [Value] attribute PxHitFlags flags;
    [Value] attribute PxVec3 position;
    [Value] attribute PxVec3 normal;
    attribute float distance;
};
PxLocationHit implements PxQueryHit;

[Prefix="physx::", NoDelete]
interface PxMaterial {
    void setDynamicFriction(float coef);
    float getDynamicFriction();
    void setStaticFriction(float coef);
    float getStaticFriction();
    void setRestitution(float coef);
    float getRestitution();
    void setDamping(float damping);
    float getDamping();
    void setFlag(PxMaterialFlagEnum flag, boolean b);
    void setFlags([Ref] PxMaterialFlags flags);
    [Value] PxMaterialFlags getFlags();
    void setFrictionCombineMode(PxCombineModeEnum combMode);
    PxCombineModeEnum getFrictionCombineMode();
    void setRestitutionCombineMode(PxCombineModeEnum combMode);
    PxCombineModeEnum getRestitutionCombineMode();
    void setDampingCombineMode(PxCombineModeEnum combMode);
    PxCombineModeEnum getDampingCombineMode();
};
PxMaterial implements PxBaseMaterial;

[Prefix="physx::"]
interface PxMaterialFlag {
};

enum PxMaterialFlagEnum {
    "PxMaterialFlag::eDISABLE_FRICTION",
    "PxMaterialFlag::eDISABLE_STRONG_FRICTION",
    "PxMaterialFlag::eIMPROVED_PATCH_FRICTION",
    "PxMaterialFlag::eCOMPLIANT_ACCELERATION_SPRING",
};

[Prefix="physx::"]
interface PxMaterialFlags {
    void PxMaterialFlags(unsigned short flags);
    void clear(PxMaterialFlagEnum flag);
    void raise(PxMaterialFlagEnum flag);
    boolean isSet(PxMaterialFlagEnum flag);
    [Ref] PxMaterialFlags setAll(PxMaterialFlagEnum flag);
};

[Prefix="physx::"]
interface PxMeshFlag {
};

enum PxMeshFlagEnum {
    "PxMeshFlag::eFLIPNORMALS",
    "PxMeshFlag::e16_BIT_INDICES",
};

[Prefix="physx::"]
interface PxMeshFlags {
    void PxMeshFlags(unsigned short flags);
    void clear(PxMeshFlagEnum flag);
    void raise(PxMeshFlagEnum flag);
    boolean isSet(PxMeshFlagEnum flag);
};

[Prefix="physx::"]
interface PxMeshGeometryFlag {
};

enum PxMeshGeometryFlagEnum {
    "PxMeshGeometryFlag::eTIGHT_BOUNDS",
    "PxMeshGeometryFlag::eDOUBLE_SIDED",
};

[Prefix="physx::"]
interface PxMeshGeometryFlags {
    void PxMeshGeometryFlags(octet flags);
    void clear(PxMeshGeometryFlagEnum flag);
    void raise(PxMeshGeometryFlagEnum flag);
    boolean isSet(PxMeshGeometryFlagEnum flag);
    [Ref] PxMeshGeometryFlags setAll(PxMeshGeometryFlagEnum flag);
};

[Prefix="physx::"]
interface PxMeshPreprocessingFlag {
};

enum PxMeshPreprocessingFlagEnum {
    "PxMeshPreprocessingFlag::eWELD_VERTICES",
    "PxMeshPreprocessingFlag::eDISABLE_CLEAN_MESH",
    "PxMeshPreprocessingFlag::eDISABLE_ACTIVE_EDGES_PRECOMPUTE",
    "PxMeshPreprocessingFlag::eFORCE_32BIT_INDICES",
    "PxMeshPreprocessingFlag::eENABLE_VERT_MAPPING",
    "PxMeshPreprocessingFlag::eENABLE_INERTIA",
};

[Prefix="physx::"]
interface PxMeshPreprocessingFlags {
    void PxMeshPreprocessingFlags(octet flags);
    void clear(PxMeshPreprocessingFlagEnum flag);
    void raise(PxMeshPreprocessingFlagEnum flag);
    boolean isSet(PxMeshPreprocessingFlagEnum flag);
    [Ref] PxMeshPreprocessingFlags setAll(PxMeshPreprocessingFlagEnum flag);
};

[Prefix="physx::"]
interface PxMeshScale {
    void PxMeshScale();
    void PxMeshScale([Const, Ref] PxVec3 s);
    void PxMeshScale([Const, Ref] PxVec3 s, [Const, Ref] PxQuat r);
    boolean isIdentity();
    [Value] PxMeshScale getInverse();
    boolean hasNegativeDeterminant();
    [Value] PxVec3 transform([Const, Ref] PxVec3 v);
    boolean isValidForTriangleMesh();
    boolean isValidForConvexMesh();
    [Value] attribute PxVec3 scale;
    [Value] attribute PxQuat rotation;
};

[Prefix="physx::"]
interface PxMidphaseDesc {
};

[Prefix="physx::"]
interface PxOverlapHit {
    void PxOverlapHit();
};
PxOverlapHit implements PxGeomOverlapHit;
PxOverlapHit implements PxActorShape;

[Prefix="physx::"]
interface PxPairFilteringMode {
};

enum PxPairFilteringModeEnum {
    "PxPairFilteringMode::eKEEP",
    "PxPairFilteringMode::eSUPPRESS",
    "PxPairFilteringMode::eKILL",
    "PxPairFilteringMode::eDEFAULT",
};

[Prefix="physx::"]
interface PxPairFlag {
};

enum PxPairFlagEnum {
    "PxPairFlag::eSOLVE_CONTACT",
    "PxPairFlag::eMODIFY_CONTACTS",
    "PxPairFlag::eNOTIFY_TOUCH_FOUND",
    "PxPairFlag::eNOTIFY_TOUCH_PERSISTS",
    "PxPairFlag::eNOTIFY_TOUCH_LOST",
    "PxPairFlag::eNOTIFY_TOUCH_CCD",
    "PxPairFlag::eNOTIFY_THRESHOLD_FORCE_FOUND",
    "PxPairFlag::eNOTIFY_THRESHOLD_FORCE_PERSISTS",
    "PxPairFlag::eNOTIFY_THRESHOLD_FORCE_LOST",
    "PxPairFlag::eNOTIFY_CONTACT_POINTS",
    "PxPairFlag::eDETECT_DISCRETE_CONTACT",
    "PxPairFlag::eDETECT_CCD_CONTACT",
    "PxPairFlag::ePRE_SOLVER_VELOCITY",
    "PxPairFlag::ePOST_SOLVER_VELOCITY",
    "PxPairFlag::eCONTACT_EVENT_POSE",
    "PxPairFlag::eCONTACT_DEFAULT",
    "PxPairFlag::eTRIGGER_DEFAULT",
};

[Prefix="physx::"]
interface PxPairFlags {
    void PxPairFlags(unsigned short flags);
    void clear(PxPairFlagEnum flag);
    void raise(PxPairFlagEnum flag);
    boolean isSet(PxPairFlagEnum flag);
    [Ref] PxPairFlags setAll(PxPairFlagEnum flag);
};

[Prefix="physx::"]
interface PxPhysics {
    void release();
    [Ref] PxFoundation getFoundation();
    [Const, Ref] PxTolerancesScale getTolerancesScale();
    unsigned long getNbTriangleMeshes();
    unsigned long getNbHeightFields();
    unsigned long getNbConvexMeshes();
    PxScene createScene([Const, Ref] PxSceneDesc sceneDesc);
    unsigned long getNbScenes();
    PxRigidStatic createRigidStatic([Const, Ref] PxTransform pose);
    PxRigidDynamic createRigidDynamic([Const, Ref] PxTransform pose);
    PxShape createShape([Const, Ref] PxGeometry geometry, [Const, Ref] PxMaterial material, optional boolean isExclusive, [Ref] optional PxShapeFlags shapeFlags);
    unsigned long getNbShapes();
    // PxConstraint createConstraint(PxRigidActor actor0, PxRigidActor actor1, [Ref] PxConstraintConnector connector, [Const, Ref] PxConstraintShaderTable shaders, unsigned long dataSize)
    PxArticulationReducedCoordinate createArticulationReducedCoordinate();
    PxMaterial createMaterial(float staticFriction, float dynamicFriction, float restitution);
    unsigned long getNbMaterials();
    [Ref] PxInsertionCallback getPhysicsInsertionCallback();
};

[Prefix="physx::"]
interface PxPlane {
    void PxPlane();
    void PxPlane(float nx, float ny, float nz, float distance);
    void PxPlane([Const, Ref] PxVec3 normal, float distance);
    void PxPlane([Const, Ref] PxVec3 p0, [Const, Ref] PxVec3 p1, [Const, Ref] PxVec3 p2);
    float distance([Const, Ref] PxVec3 p);
    boolean contains([Const, Ref] PxVec3 p);
    [Value] PxVec3 project([Const, Ref] PxVec3 p);
    [Value] PxVec3 pointInPlane();
    void normalize();
    [Value] PxPlane transform([Const, Ref] PxTransform pose);
    [Value] PxPlane inverseTransform([Const, Ref] PxTransform pose);
    [Value] attribute PxVec3 n;
    attribute float d;
};

[Prefix="physx::"]
interface PxPlaneGeometry {
    void PxPlaneGeometry();
};
PxPlaneGeometry implements PxGeometry;

[Prefix="physx::"]
interface PxPrismaticJoint {
    float getPosition();
    float getVelocity();
    void setLimit([Const, Ref] PxJointLinearLimitPair limit);
    // [Value] PxJointLinearLimitPair getLimit();
    void setPrismaticJointFlags([Ref] PxPrismaticJointFlags flags);
    void setPrismaticJointFlag(PxPrismaticJointFlagEnum flag, boolean value);
    [Value] PxPrismaticJointFlags getPrismaticJointFlags();
};
PxPrismaticJoint implements PxJoint;

[Prefix="physx::"]
interface PxPrismaticJointFlag {
};

enum PxPrismaticJointFlagEnum {
    "PxPrismaticJointFlag::eLIMIT_ENABLED",
};

[Prefix="physx::"]
interface PxPrismaticJointFlags {
    void PxPrismaticJointFlags(unsigned short flags);
    void clear(PxPrismaticJointFlagEnum flag);
    void raise(PxPrismaticJointFlagEnum flag);
    boolean isSet(PxPrismaticJointFlagEnum flag);
    [Ref] PxPrismaticJointFlags setAll(PxPrismaticJointFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxPvd {
    void release();
};

[Prefix="physx::"]
interface PxQuat {
    void PxQuat();
    void PxQuat(PxIDENTITYEnum identity);
    void PxQuat(float x, float y, float z, float w);
    boolean isIdentity();
    boolean isFinite();
    boolean isUnit();
    boolean isSane();
    float getAngle();
    float getAngle([Const, Ref] PxQuat q);
    float magnitudeSquared();
    float dot([Const, Ref] PxQuat q);
    [Value] PxQuat getNormalized();
    float magnitude();
    float normalize();
    [Value] PxQuat getConjugate();
    [Value] PxVec3 getImaginaryPart();
    [Value] PxVec3 getBasisVector0();
    [Value] PxVec3 getBasisVector1();
    [Value] PxVec3 getBasisVector2();
    [Value] PxVec3 rotate([Const, Ref] PxVec3 v);
    [Value] PxVec3 rotateInv([Const, Ref] PxVec3 v);
    attribute float x;
    attribute float y;
    attribute float z;
    attribute float w;
};

[Prefix="physx::"]
interface PxQueryFilterCallback {
};

[JSImplementation="PxQueryFilterCallbackSimple"]
interface PxQueryFilterCallbackImpl {
    void PxQueryFilterCallbackImpl();
    unsigned long onPreFilter([Const, Ref] PxFilterData filterData, [Const] PxShape shape, [Const] PxRigidActor actor, [Ref] PxHitFlags queryFlags);
    unsigned long onPostFilter([Const, Ref] PxFilterData filterData, [Const, Ref] PxQueryHit hit, [Const] PxShape shape, [Const] PxRigidActor actor);
};

interface PxQueryFilterCallbackSimple {
};
PxQueryFilterCallbackSimple implements PxQueryFilterCallback;

[Prefix="physx::"]
interface PxQueryFilterData {
    void PxQueryFilterData();
    void PxQueryFilterData([Const, Ref] PxFilterData data, [Ref] PxQueryFlags flags);
    void PxQueryFilterData([Ref] PxQueryFlags flags);
    [Value] attribute PxFilterData data;
    [Value] attribute PxQueryFlags flags;
};

[Prefix="physx::"]
interface PxQueryFlag {
};

enum PxQueryFlagEnum {
    "PxQueryFlag::eSTATIC",
    "PxQueryFlag::eDYNAMIC",
    "PxQueryFlag::ePREFILTER",
    "PxQueryFlag::ePOSTFILTER",
    "PxQueryFlag::eANY_HIT",
    "PxQueryFlag::eNO_BLOCK",
    "PxQueryFlag::eBATCH_QUERY_LEGACY_BEHAVIOUR",
    "PxQueryFlag::eDISABLE_HARDCODED_FILTER",
    "PxQueryFlag::eRESERVED",
};

[Prefix="physx::"]
interface PxQueryFlags {
    void PxQueryFlags(unsigned short flags);
    void clear(PxQueryFlagEnum flag);
    void raise(PxQueryFlagEnum flag);
    boolean isSet(PxQueryFlagEnum flag);
    [Ref] PxQueryFlags setAll(PxQueryFlagEnum flag);
};

[Prefix="physx::"]
interface PxQueryHit {
    attribute unsigned long faceIndex;
};

[Prefix="physx::"]
interface PxQueryHitType {
};

enum PxQueryHitTypeEnum {
    "PxQueryHitType::eNONE",
    "PxQueryHitType::eTOUCH",
    "PxQueryHitType::eBLOCK",
};

[Prefix="physx::"]
interface PxRaycastHit {
    void PxRaycastHit();
};
PxRaycastHit implements PxGeomRaycastHit;
PxRaycastHit implements PxActorShape;

[Prefix="physx::", NoDelete]
interface PxRefCounted {
    unsigned long getReferenceCount();
    void acquireReference();
};
PxRefCounted implements PxBase;

[Prefix="physx::", NoDelete]
interface PxRenderBuffer {
    unsigned long getNbPoints();
    [Const] PxDebugPoint getPoints();
    void addPoint([Const, Ref] PxDebugPoint point);
    unsigned long getNbLines();
    [Const] PxDebugLine getLines();
    void addLine([Const, Ref] PxDebugLine line);
    PxDebugLine reserveLines([Const] unsigned long nbLines);
    PxDebugPoint reservePoints([Const] unsigned long nbLines);
    unsigned long getNbTriangles();
    [Const] PxDebugTriangle getTriangles();
    void addTriangle([Const, Ref] PxDebugTriangle triangle);
    void append([Const, Ref] PxRenderBuffer other);
    void clear();
    void shift([Const, Ref] PxVec3 delta);
    boolean empty();
};

[Prefix="physx::"]
interface PxRevoluteJoint {
    float getAngle();
    float getVelocity();
    void setLimit([Const, Ref] PxJointAngularLimitPair limits);
    // [Value] PxJointAngularLimitPair getLimit();
    void setDriveVelocity(float velocity, optional boolean autowake);
    float getDriveVelocity();
    void setDriveForceLimit(float limit);
    float getDriveForceLimit();
    void setDriveGearRatio(float ratio);
    float getDriveGearRatio();
    void setRevoluteJointFlags([Ref] PxRevoluteJointFlags flags);
    void setRevoluteJointFlag(PxRevoluteJointFlagEnum flag, boolean value);
    [Value] PxRevoluteJointFlags getRevoluteJointFlags();
};
PxRevoluteJoint implements PxJoint;

[Prefix="physx::"]
interface PxRevoluteJointFlag {
};

enum PxRevoluteJointFlagEnum {
    "PxRevoluteJointFlag::eLIMIT_ENABLED",
    "PxRevoluteJointFlag::eDRIVE_ENABLED",
    "PxRevoluteJointFlag::eDRIVE_FREESPIN",
};

[Prefix="physx::"]
interface PxRevoluteJointFlags {
    void PxRevoluteJointFlags(unsigned short flags);
    void clear(PxRevoluteJointFlagEnum flag);
    void raise(PxRevoluteJointFlagEnum flag);
    boolean isSet(PxRevoluteJointFlagEnum flag);
    [Ref] PxRevoluteJointFlags setAll(PxRevoluteJointFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxRigidActor {
    [Value] PxTransform getGlobalPose();
    void setGlobalPose([Const, Ref] PxTransform pose, optional boolean autowake);
    boolean attachShape([Ref] PxShape shape);
    void detachShape([Ref] PxShape shape, optional boolean wakeOnLostTouch);
    unsigned long getNbShapes();
    unsigned long getNbConstraints();
};
PxRigidActor implements PxActor;

[Prefix="physx::"]
interface PxRigidActorExt {
    static PxShape createExclusiveShape([Ref] PxRigidActor actor, [Const, Ref] PxGeometry geometry, [Const, Ref] PxMaterial material, [Ref] optional PxShapeFlags flags);
};

[Prefix="physx::", NoDelete]
interface PxRigidBody {
    void setCMassLocalPose([Const, Ref] PxTransform pose);
    [Value] PxTransform getCMassLocalPose();
    void setMass(float mass);
    float getMass();
    float getInvMass();
    void setMassSpaceInertiaTensor([Const, Ref] PxVec3 m);
    [Value] PxVec3 getMassSpaceInertiaTensor();
    [Value] PxVec3 getMassSpaceInvInertiaTensor();
    void setLinearDamping(float linDamp);
    float getLinearDamping();
    void setAngularDamping(float angDamp);
    float getAngularDamping();
    [Value] PxVec3 getLinearVelocity();
    [Value] PxVec3 getAngularVelocity();
    void setMaxLinearVelocity(float maxLinVel);
    float getMaxLinearVelocity();
    void setMaxAngularVelocity(float maxAngVel);
    float getMaxAngularVelocity();
    [Value] PxVec3 getLinearAcceleration();
    [Value] PxVec3 getAngularAcceleration();
    void addForce([Const, Ref] PxVec3 force, optional PxForceModeEnum mode, optional boolean autowake);
    void addTorque([Const, Ref] PxVec3 torque, optional PxForceModeEnum mode, optional boolean autowake);
    void clearForce(optional PxForceModeEnum mode);
    void clearTorque(optional PxForceModeEnum mode);
    void setForceAndTorque([Const, Ref] PxVec3 force, [Const, Ref] PxVec3 torque, optional PxForceModeEnum mode);
    void setRigidBodyFlag(PxRigidBodyFlagEnum flag, boolean value);
    void setRigidBodyFlags([Ref] PxRigidBodyFlags inFlags);
    [Value] PxRigidBodyFlags getRigidBodyFlags();
    void setMinCCDAdvanceCoefficient(float advanceCoefficient);
    float getMinCCDAdvanceCoefficient();
    void setMaxDepenetrationVelocity(float biasClamp);
    float getMaxDepenetrationVelocity();
    void setMaxContactImpulse(float maxImpulse);
    float getMaxContactImpulse();
    void setContactSlopCoefficient(float slopCoefficient);
    float getContactSlopCoefficient();
};
PxRigidBody implements PxRigidActor;

[Prefix="physx::"]
interface PxRigidBodyExt {
    static boolean updateMassAndInertia([Ref] PxRigidBody body, float density, optional PxVec3 massLocalPose, optional boolean includeNonSimShapes);
    static boolean setMassAndUpdateInertia([Ref] PxRigidBody body, float mass, optional PxVec3 massLocalPose, optional boolean includeNonSimShapes);
    static void addForceAtPos([Ref] PxRigidBody body, [Const, Ref] PxVec3 force, [Const, Ref] PxVec3 pos, optional PxForceModeEnum mode, optional boolean wakeup);
    static void addForceAtLocalPos([Ref] PxRigidBody body, [Const, Ref] PxVec3 force, [Const, Ref] PxVec3 pos, optional PxForceModeEnum mode, optional boolean wakeup);
    static void addLocalForceAtPos([Ref] PxRigidBody body, [Const, Ref] PxVec3 force, [Const, Ref] PxVec3 pos, optional PxForceModeEnum mode, optional boolean wakeup);
    static void addLocalForceAtLocalPos([Ref] PxRigidBody body, [Const, Ref] PxVec3 force, [Const, Ref] PxVec3 pos, optional PxForceModeEnum mode, optional boolean wakeup);
    [Value] static PxVec3 getVelocityAtPos([Const, Ref] PxRigidBody body, [Const, Ref] PxVec3 pos);
    [Value] static PxVec3 getLocalVelocityAtLocalPos([Const, Ref] PxRigidBody body, [Const, Ref] PxVec3 pos);
    [Value] static PxVec3 getVelocityAtOffset([Const, Ref] PxRigidBody body, [Const, Ref] PxVec3 pos);
    static void computeVelocityDeltaFromImpulse([Const, Ref] PxRigidBody body, [Const, Ref] PxVec3 impulsiveForce, [Const, Ref] PxVec3 impulsiveTorque, [Ref] PxVec3 deltaLinearVelocity, [Ref] PxVec3 deltaAngularVelocity);
    static void computeVelocityDeltaFromImpulse([Const, Ref] PxRigidBody body, [Const, Ref] PxTransform globalPose, [Const, Ref] PxVec3 point, [Const, Ref] PxVec3 impulse, float invMassScale, float invInertiaScale, [Ref] PxVec3 deltaLinearVelocity, [Ref] PxVec3 deltaAngularVelocity);
    static void computeLinearAngularImpulse([Const, Ref] PxRigidBody body, [Const, Ref] PxTransform globalPose, [Const, Ref] PxVec3 point, [Const, Ref] PxVec3 impulse, float invMassScale, float invInertiaScale, [Ref] PxVec3 linearImpulse, [Ref] PxVec3 angularImpulse);
};

[Prefix="physx::"]
interface PxRigidBodyFlag {
};

enum PxRigidBodyFlagEnum {
    "PxRigidBodyFlag::eKINEMATIC",
    "PxRigidBodyFlag::eUSE_KINEMATIC_TARGET_FOR_SCENE_QUERIES",
    "PxRigidBodyFlag::eENABLE_CCD",
    "PxRigidBodyFlag::eENABLE_CCD_FRICTION",
    "PxRigidBodyFlag::eENABLE_SPECULATIVE_CCD",
    "PxRigidBodyFlag::eENABLE_POSE_INTEGRATION_PREVIEW",
    "PxRigidBodyFlag::eENABLE_CCD_MAX_CONTACT_IMPULSE",
    "PxRigidBodyFlag::eRETAIN_ACCELERATIONS",
    "PxRigidBodyFlag::eFORCE_KINE_KINE_NOTIFICATIONS",
    "PxRigidBodyFlag::eFORCE_STATIC_KINE_NOTIFICATIONS",
    "PxRigidBodyFlag::eENABLE_GYROSCOPIC_FORCES",
    "PxRigidBodyFlag::eRESERVED",
};

[Prefix="physx::"]
interface PxRigidBodyFlags {
    void PxRigidBodyFlags(unsigned short flags);
    void clear(PxRigidBodyFlagEnum flag);
    void raise(PxRigidBodyFlagEnum flag);
    boolean isSet(PxRigidBodyFlagEnum flag);
    [Ref] PxRigidBodyFlags setAll(PxRigidBodyFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxRigidDynamic {
    void setKinematicTarget([Const, Ref] PxTransform destination);
    boolean isSleeping();
    void setSleepThreshold(float threshold);
    float getSleepThreshold();
    void setStabilizationThreshold(float threshold);
    float getStabilizationThreshold();
    void setWakeCounter(float wakeCounterValue);
    float getWakeCounter();
    void wakeUp();
    void putToSleep();
    [Value] PxRigidDynamicLockFlags getRigidDynamicLockFlags();
    void setRigidDynamicLockFlag(PxRigidDynamicLockFlagEnum flag, boolean value);
    void setRigidDynamicLockFlags([Ref] PxRigidDynamicLockFlags flags);
    void setLinearVelocity([Const, Ref] PxVec3 linVel, optional boolean autowake);
    void setAngularVelocity([Const, Ref] PxVec3 angVel, optional boolean autowake);
    float getContactReportThreshold();
    void setContactReportThreshold(float threshold);
};
PxRigidDynamic implements PxRigidBody;

[Prefix="physx::"]
interface PxRigidDynamicLockFlag {
};

enum PxRigidDynamicLockFlagEnum {
    "PxRigidDynamicLockFlag::eLOCK_LINEAR_X",
    "PxRigidDynamicLockFlag::eLOCK_LINEAR_Y",
    "PxRigidDynamicLockFlag::eLOCK_LINEAR_Z",
    "PxRigidDynamicLockFlag::eLOCK_ANGULAR_X",
    "PxRigidDynamicLockFlag::eLOCK_ANGULAR_Y",
    "PxRigidDynamicLockFlag::eLOCK_ANGULAR_Z",
};

[Prefix="physx::"]
interface PxRigidDynamicLockFlags {
    void PxRigidDynamicLockFlags(octet flags);
    void clear(PxRigidDynamicLockFlagEnum flag);
    void raise(PxRigidDynamicLockFlagEnum flag);
    boolean isSet(PxRigidDynamicLockFlagEnum flag);
    [Ref] PxRigidDynamicLockFlags setAll(PxRigidDynamicLockFlagEnum flag);
};

[Prefix="physx::", NoDelete]
interface PxRigidStatic {
};
PxRigidStatic implements PxRigidActor;

[Prefix="physx::", NoDelete]
interface PxScene {
    void release();
    void shiftOrigin([Const, Ref] PxVec3 shift);
    void setFlag(PxSceneFlagEnum flag, boolean value);
    [Value] PxSceneFlags getFlags();
    void setLimits([Const, Ref] PxSceneLimits limits);
    [Value] PxSceneLimits getLimits();
    [Ref] PxPhysics getPhysics();
    unsigned long getTimestamp();
    void setName([Const] DOMString name);
    [Const] DOMString getName();
    boolean addArticulation([Ref] PxArticulationReducedCoordinate articulation);
    void removeArticulation([Ref] PxArticulationReducedCoordinate articulation, optional boolean wakeOnLostTouch);
    boolean addActor([Ref] PxActor actor);
    void removeActor([Ref] PxActor actor, optional boolean wakeOnLostTouch);
    unsigned long getNbActors([Ref] PxActorTypeFlags types);
    unsigned long getNbArticulations();
    unsigned long getNbConstraints();
    PxCpuDispatcher getCpuDispatcher();
    void setSimulationEventCallback(PxSimulationEventCallback callback);
    PxSimulationEventCallback getSimulationEventCallback();
    void setFilterShaderData([Const] VoidPtr data, unsigned long dataSize);
    [Const] VoidPtr getFilterShaderData();
    unsigned long getFilterShaderDataSize();
    [Value] PxSimulationFilterShader getFilterShader();
    boolean resetFiltering([Ref] PxActor actor);
    PxPairFilteringModeEnum getKinematicKinematicFilteringMode();
    PxPairFilteringModeEnum getStaticKinematicFilteringMode();
    boolean simulate(float elapsedTime);
    boolean advance();
    boolean collide(float elapsedTime);
    boolean checkResults(optional boolean block);
    boolean fetchCollision(optional boolean block);
    boolean fetchResults(optional boolean block);
    void flushSimulation(optional boolean sendPendingReports);
    void setGravity([Const, Ref] PxVec3 vec);
    [Value] PxVec3 getGravity();
    void setBounceThresholdVelocity(float t);
    float getBounceThresholdVelocity();
    void setCCDMaxPasses(unsigned long ccdMaxPasses);
    unsigned long getCCDMaxPasses();
    void setCCDMaxSeparation(float t);
    float getCCDMaxSeparation();
    void setCCDThreshold(float t);
    float getCCDThreshold();
    void setMaxBiasCoefficient(float t);
    float getMaxBiasCoefficient();
    void setFrictionOffsetThreshold(float t);
    float getFrictionOffsetThreshold();
    void setFrictionCorrelationDistance(float t);
    float getFrictionCorrelationDistance();
    PxFrictionTypeEnum getFrictionType();
    PxSolverTypeEnum getSolverType();
    boolean setVisualizationParameter(PxVisualizationParameterEnum param, float value);
    float getVisualizationParameter(PxVisualizationParameterEnum paramEnum);
    [Const, Ref] PxRenderBuffer getRenderBuffer();
    attribute VoidPtr userData;
};

[Prefix="physx::"]
interface PxSceneDesc {
    void PxSceneDesc([Const, Ref] PxTolerancesScale scale);
    [Value] attribute PxVec3 gravity;
    attribute PxSimulationEventCallback simulationEventCallback;
    [Const] attribute VoidPtr filterShaderData;
    attribute unsigned long filterShaderDataSize;
    [Value] attribute PxSimulationFilterShader filterShader;
    attribute PxPairFilteringModeEnum kineKineFilteringMode;
    attribute PxPairFilteringModeEnum staticKineFilteringMode;
    [Value] attribute PxSceneLimits limits;
    attribute PxFrictionTypeEnum frictionType;
    attribute PxSolverTypeEnum solverType;
    attribute float bounceThresholdVelocity;
    attribute float frictionOffsetThreshold;
    attribute float frictionCorrelationDistance;
    [Value] attribute PxSceneFlags flags;
    attribute PxCpuDispatcher cpuDispatcher;
    attribute VoidPtr userData;
};

[Prefix="physx::"]
interface PxSceneFlag {
};

enum PxSceneFlagEnum {
    "PxSceneFlag::eENABLE_ACTIVE_ACTORS",
    "PxSceneFlag::eENABLE_CCD",
    "PxSceneFlag::eDISABLE_CCD_RESWEEP",
    "PxSceneFlag::eENABLE_PCM",
    "PxSceneFlag::eDISABLE_CONTACT_REPORT_BUFFER_RESIZE",
    "PxSceneFlag::eDISABLE_CONTACT_CACHE",
    "PxSceneFlag::eREQUIRE_RW_LOCK",
    "PxSceneFlag::eENABLE_STABILIZATION",
    "PxSceneFlag::eENABLE_AVERAGE_POINT",
    "PxSceneFlag::eEXCLUDE_KINEMATICS_FROM_ACTIVE_ACTORS",
    "PxSceneFlag::eENABLE_GPU_DYNAMICS",
    "PxSceneFlag::eENABLE_ENHANCED_DETERMINISM",
    "PxSceneFlag::eENABLE_FRICTION_EVERY_ITERATION",
    "PxSceneFlag::eENABLE_EXTERNAL_FORCES_EVERY_ITERATION_TGS",
    "PxSceneFlag::eENABLE_DIRECT_GPU_API",
    "PxSceneFlag::eENABLE_BODY_ACCELERATIONS",
    "PxSceneFlag::eENABLE_SOLVER_RESIDUAL_REPORTING",
    "PxSceneFlag::eMUTABLE_FLAGS",
};

[Prefix="physx::"]
interface PxSceneFlags {
    void PxSceneFlags(unsigned long flags);
    void clear(PxSceneFlagEnum flag);
    void raise(PxSceneFlagEnum flag);
    boolean isSet(PxSceneFlagEnum flag);
    [Ref] PxSceneFlags setAll(PxSceneFlagEnum flag);
};

[Prefix="physx::"]
interface PxSceneLimits {
    void PxSceneLimits();
    attribute unsigned long maxNbActors;
    attribute unsigned long maxNbBodies;
    attribute unsigned long maxNbStaticShapes;
    attribute unsigned long maxNbDynamicShapes;
    attribute unsigned long maxNbAggregates;
    attribute unsigned long maxNbConstraints;
    attribute unsigned long maxNbRegions;
    attribute unsigned long maxNbBroadPhaseOverlaps;
};

[Prefix="physx::", NoDelete]
interface PxShape {
    void setSimulationFilterData([Const, Ref] PxFilterData data);
    [Value] PxFilterData getSimulationFilterData();
    void setQueryFilterData([Const, Ref] PxFilterData data);
    [Value] PxFilterData getQueryFilterData();
    unsigned short getNbMaterials();
    void setContactOffset(float contactOffset);
    float getContactOffset();
    void setRestOffset(float restOffset);
    float getRestOffset();
    void setDensityForFluid(float densityForFluid);
    float getDensityForFluid();
    void setTorsionalPatchRadius(float radius);
    float getTorsionalPatchRadius();
    void setMinTorsionalPatchRadius(float radius);
    float getMinTorsionalPatchRadius();
    void setFlag(PxShapeFlagEnum flag, boolean value);
    void setFlags([Ref] PxShapeFlags inFlags);
    [Value] PxShapeFlags getFlags();
    boolean isExclusive();
    void setName([Const] DOMString name);
    [Const] DOMString getName();
    void setLocalPose([Const, Ref] PxTransform pose);
    [Value] PxTransform getLocalPose();
    void setGeometry([Const, Ref] PxGeometry geometry);
    [Const, Ref] PxGeometry getGeometry();
    PxRigidActor getActor();
    attribute VoidPtr userData;
};
PxShape implements PxRefCounted;

[Prefix="physx::"]
interface PxShapeExt {
    [Value] static PxTransform getGlobalPose([Const, Ref] PxShape shape, [Const, Ref] PxRigidActor actor);
    static unsigned long raycast([Const, Ref] PxShape shape, [Const, Ref] PxRigidActor actor, [Const, Ref] PxVec3 rayOrigin, [Const, Ref] PxVec3 rayDir, float maxDist, [Ref] PxHitFlags hitFlags, unsigned long maxHits, PxRaycastHit rayHits);
    static boolean overlap([Const, Ref] PxShape shape, [Const, Ref] PxRigidActor actor, [Const, Ref] PxGeometry otherGeom, [Const, Ref] PxTransform otherGeomPose);
    static boolean sweep([Const, Ref] PxShape shape, [Const, Ref] PxRigidActor actor, [Const, Ref] PxVec3 unitDir, float distance, [Const, Ref] PxGeometry otherGeom, [Const, Ref] PxTransform otherGeomPose, [Ref] PxSweepHit sweepHit, [Ref] PxHitFlags hitFlags);
    [Value] static PxBounds3 getWorldBounds([Const, Ref] PxShape shape, [Const, Ref] PxRigidActor actor, optional float inflation);
};

[Prefix="physx::"]
interface PxShapeFlag {
};

enum PxShapeFlagEnum {
    "PxShapeFlag::eSIMULATION_SHAPE",
    "PxShapeFlag::eSCENE_QUERY_SHAPE",
    "PxShapeFlag::eTRIGGER_SHAPE",
    "PxShapeFlag::eVISUALIZATION",
};

[Prefix="physx::"]
interface PxShapeFlags {
    void PxShapeFlags(octet flags);
    void clear(PxShapeFlagEnum flag);
    void raise(PxShapeFlagEnum flag);
    boolean isSet(PxShapeFlagEnum flag);
    [Ref] PxShapeFlags setAll(PxShapeFlagEnum flag);
};

[Prefix="physx::"]
interface PxSimpleTriangleMesh {
    [Value] attribute PxBoundedData points;
    [Value] attribute PxBoundedData triangles;
    [Value] attribute PxMeshFlags flags;
};

[Prefix="physx::"]
interface PxSimulationEventCallback {
};

[JSImplementation="PxSimulationEventCallbackSimple"]
interface PxSimulationEventCallbackImpl {
    void PxSimulationEventCallbackImpl();
    void onConstraintBreak(PxConstraintInfo constraints, unsigned long count);
    void onWake(PxActorPtr actors, unsigned long count);
    void onSleep(PxActorPtr actors, unsigned long count);
    void onContact([Const, Ref] PxContactPairHeader pairHeader, [Const] PxContactPair pairs, unsigned long nbPairs);
    void onTrigger(PxTriggerPair pairs, unsigned long count);
};

interface PxSimulationEventCallbackSimple {
};
PxSimulationEventCallbackSimple implements PxSimulationEventCallback;

[Prefix="physx::"]
interface PxSimulationFilterShader {
};

interface PxSimulationFilterShaderCallback {
};

[JSImplementation="PxSimulationFilterShaderCallback"]
interface PxSimulationFilterShaderCallbackImpl {
    void PxSimulationFilterShaderCallbackImpl();
    unsigned long onFilterShader(unsigned long attributes0, [Const, Ref] PxFilterData filterData0, unsigned long attributes1, [Const, Ref] PxFilterData filterData1, [Const, Ref] PxPairFlags pairFlags);
};

[Prefix="physx::"]
interface PxSolverType {
};

enum PxSolverTypeEnum {
    "PxSolverType::ePGS",
    "PxSolverType::eTGS",
};

[Prefix="physx::"]
interface PxSpatialVelocity {
    [Value] attribute PxVec3 linear;
    [Value] attribute PxVec3 angular;
};

[Prefix="physx::"]
interface PxSphereGeometry {
    void PxSphereGeometry();
    void PxSphereGeometry(float radius);
    attribute float radius;
};
PxSphereGeometry implements PxGeometry;

[Prefix="physx::"]
interface PxSphericalJoint {
    void setLimitCone([Const, Ref] PxJointLimitCone limitCone);
    // [Value] PxJointLimitCone getLimitCone();
    float getSwingYAngle();
    float getSwingZAngle();
    void setSphericalJointFlags([Ref] PxSphericalJointFlags flags);
    void setSphericalJointFlag(PxSphericalJointFlagEnum flag, boolean value);
    [Value] PxSphericalJointFlags getSphericalJointFlags();
};
PxSphericalJoint implements PxJoint;

[Prefix="physx::"]
interface PxSphericalJointFlag {
};

enum PxSphericalJointFlagEnum {
    "PxSphericalJointFlag::eLIMIT_ENABLED",
};

[Prefix="physx::"]
interface PxSphericalJointFlags {
    void PxSphericalJointFlags(unsigned short flags);
    void clear(PxSphericalJointFlagEnum flag);
    void raise(PxSphericalJointFlagEnum flag);
    boolean isSet(PxSphericalJointFlagEnum flag);
    [Ref] PxSphericalJointFlags setAll(PxSphericalJointFlagEnum flag);
};

[Prefix="physx::"]
interface PxSpring {
    void PxSpring(float stiffness, float damping);
    attribute float stiffness;
    attribute float damping;
};

[Prefix="physx::"]
interface PxStridedData {
    void PxStridedData();
    attribute unsigned long stride;
    [Const] attribute VoidPtr data;
};

[Prefix="physx::"]
interface PxSweepHit {
    void PxSweepHit();
};
PxSweepHit implements PxGeomSweepHit;
PxSweepHit implements PxActorShape;

[Prefix="physx::"]
interface PxTolerancesScale {
    void PxTolerancesScale(optional float defaultLength, optional float defaultSpeed);
    attribute float length;
    attribute float speed;
};

[Prefix="physx::"]
interface PxTransform {
    void PxTransform();
    void PxTransform(PxIDENTITYEnum identity);
    void PxTransform(float x, float y, float z, [Const, Ref] PxQuat q);
    void PxTransform([Const, Ref] PxVec3 p, [Const, Ref] PxQuat q);
    [Value] PxTransform getInverse();
    [Value] PxTransform getNormalized();
    [Value] PxVec3 transform([Const, Ref] PxVec3 p);
    [Value] PxVec3 transformInv([Const, Ref] PxVec3 p);
    [Value] PxVec3 rotate([Const, Ref] PxVec3 p);
    [Value] PxVec3 rotateInv([Const, Ref] PxVec3 p);
    boolean isSane();
    boolean isFinite();
    [Value] attribute PxQuat q;
    [Value] attribute PxVec3 p;
};

[Prefix="physx::", NoDelete]
interface PxTriangleMesh {
    unsigned long getNbVertices();
    [Const] PxVec3 getVertices();
    PxVec3 getVerticesForModification();
    [Value] PxBounds3 refitBVH();
    unsigned long getNbTriangles();
    [Const] VoidPtr getTriangles();
    [Value] PxTriangleMeshFlags getTriangleMeshFlags();
    unsigned short getTriangleMaterialIndex(unsigned long triangleIndex);
    [Value] PxBounds3 getLocalBounds();
};
PxTriangleMesh implements PxRefCounted;

[Prefix="physx::"]
interface PxTriangleMeshDesc {
    void PxTriangleMeshDesc();
};
PxTriangleMeshDesc implements PxSimpleTriangleMesh;

[Prefix="physx::"]
interface PxTriangleMeshFlag {
};

enum PxTriangleMeshFlagEnum {
    "PxTriangleMeshFlag::e16_BIT_INDICES",
    "PxTriangleMeshFlag::eADJACENCY_INFO",
    "PxTriangleMeshFlag::ePREFER_NO_SDF_PROJ",
};

[Prefix="physx::"]
interface PxTriangleMeshFlags {
    void PxTriangleMeshFlags(octet flags);
    void clear(PxTriangleMeshFlagEnum flag);
    void raise(PxTriangleMeshFlagEnum flag);
    boolean isSet(PxTriangleMeshFlagEnum flag);
    [Ref] PxTriangleMeshFlags setAll(PxTriangleMeshFlagEnum flag);
};

[Prefix="physx::"]
interface PxTriangleMeshGeometry {
    void PxTriangleMeshGeometry(optional PxTriangleMesh mesh, [Const, Ref] optional PxMeshScale scaling, [Ref] optional PxMeshGeometryFlags flags);
    [Value] attribute PxMeshScale scale;
    [Value] attribute PxMeshGeometryFlags meshFlags;
    attribute PxTriangleMesh triangleMesh;
};
PxTriangleMeshGeometry implements PxGeometry;

[Prefix="physx::"]
interface PxTriggerPair {
    attribute PxShape triggerShape;
    attribute PxActor triggerActor;
    attribute PxShape otherShape;
    attribute PxActor otherActor;
    attribute PxPairFlagEnum status;
    [Value] attribute PxTriggerPairFlags flags;
};

[Prefix="physx::"]
interface PxTriggerPairFlag {
};

enum PxTriggerPairFlagEnum {
    "PxTriggerPairFlag::eREMOVED_SHAPE_TRIGGER",
    "PxTriggerPairFlag::eREMOVED_SHAPE_OTHER",
};

[Prefix="physx::"]
interface PxTriggerPairFlags {
    void PxTriggerPairFlags(octet flags);
    void clear(PxTriggerPairFlagEnum flag);
    void raise(PxTriggerPairFlagEnum flag);
    boolean isSet(PxTriggerPairFlagEnum flag);
    [Ref] PxTriggerPairFlags setAll(PxTriggerPairFlagEnum flag);
};

[Prefix="physx::"]
interface PxVec3 {
    void PxVec3();
    void PxVec3(PxZEROEnum zero);
    void PxVec3(float x, float y, float z);
    boolean isZero();
    boolean isFinite();
    boolean isNormalized();
    float magnitudeSquared();
    float magnitude();
    float dot([Const, Ref] PxVec3 v);
    [Value] PxVec3 cross([Const, Ref] PxVec3 v);
    [Value] PxVec3 getNormalized();
    float normalize();
    float normalizeSafe();
    float normalizeFast();
    [Value] PxVec3 multiply([Const, Ref] PxVec3 a);
    [Value] PxVec3 minimum([Const, Ref] PxVec3 v);
    float minElement();
    [Value] PxVec3 maximum([Const, Ref] PxVec3 v);
    float maxElement();
    [Value] PxVec3 abs();
    attribute float x;
    attribute float y;
    attribute float z;
};

[Prefix="physx::"]
interface PxVisualizationParameter {
};

enum PxVisualizationParameterEnum {
    "PxVisualizationParameter::eSCALE",
    "PxVisualizationParameter::eWORLD_AXES",
    "PxVisualizationParameter::eBODY_AXES",
    "PxVisualizationParameter::eBODY_MASS_AXES",
    "PxVisualizationParameter::eBODY_LIN_VELOCITY",
    "PxVisualizationParameter::eBODY_ANG_VELOCITY",
    "PxVisualizationParameter::eCONTACT_POINT",
    "PxVisualizationParameter::eCONTACT_NORMAL",
    "PxVisualizationParameter::eCONTACT_ERROR",
    "PxVisualizationParameter::eCONTACT_IMPULSE",
    "PxVisualizationParameter::eFRICTION_POINT",
    "PxVisualizationParameter::eFRICTION_NORMAL",
    "PxVisualizationParameter::eFRICTION_IMPULSE",
    "PxVisualizationParameter::eACTOR_AXES",
    "PxVisualizationParameter::eCOLLISION_AABBS",
    "PxVisualizationParameter::eCOLLISION_SHAPES",
    "PxVisualizationParameter::eCOLLISION_AXES",
    "PxVisualizationParameter::eCOLLISION_COMPOUNDS",
    "PxVisualizationParameter::eCOLLISION_FNORMALS",
    "PxVisualizationParameter::eCOLLISION_EDGES",
    "PxVisualizationParameter::eCOLLISION_STATIC",
    "PxVisualizationParameter::eCOLLISION_DYNAMIC",
    "PxVisualizationParameter::eJOINT_LOCAL_FRAMES",
    "PxVisualizationParameter::eJOINT_LIMITS",
    "PxVisualizationParameter::eCULL_BOX",
    "PxVisualizationParameter::eMBP_REGIONS",
    "PxVisualizationParameter::eSIMULATION_MESH",
    "PxVisualizationParameter::eSDF",
    "PxVisualizationParameter::eNUM_VALUES",
};

[Prefix="physx::"]
interface PxZERO {
};

enum PxZEROEnum {
    "PxZERO::PxZero",
};

[NoDelete]
interface TopLevelFunctions {
    [Value] static PxSimulationFilterShader DefaultFilterShader();
    [Value] static PxSimulationFilterShader CustomFilterShader(PxSimulationFilterShaderCallback filterShader);
    static boolean FilterObjectIsKinematic(unsigned long attributes);
    static boolean FilterObjectIsTrigger(unsigned long attributes);
    static PxFoundation CreateFoundation(unsigned long version, [Ref] PxAllocatorCallback allocator, [Ref] PxErrorCallback errorCallback);
    static PxPhysics CreatePhysics(unsigned long version, [Ref] PxFoundation foundation, [Const, Ref] PxTolerancesScale params, optional boolean trackOutstandingAllocations, optional PxPvd pvd);
    static PxPvd CreatePvd([Ref] PxFoundation foundation);
    static PxControllerManager CreateControllerManager([Ref] PxScene scene, optional boolean lockingEnabled);
    static PxDefaultCpuDispatcher CreateDefaultCpuDispatcher(unsigned long numThreads);
    static boolean InitExtensions([Ref] PxPhysics physics, PxPvd pvd);
    static void CloseExtensions();
    static PxD6Joint CreateD6Joint([Ref] PxPhysics physics, PxRigidActor actor0, [Ref] PxTransform localFrame0, PxRigidActor actor1, [Ref] PxTransform localFrame1);
    static PxDistanceJoint CreateDistanceJoint([Ref] PxPhysics physics, PxRigidActor actor0, [Ref] PxTransform localFrame0, PxRigidActor actor1, [Ref] PxTransform localFrame1);
    static PxFixedJoint CreateFixedJoint([Ref] PxPhysics physics, PxRigidActor actor0, [Ref] PxTransform localFrame0, PxRigidActor actor1, [Ref] PxTransform localFrame1);
    static PxPrismaticJoint CreatePrismaticJoint([Ref] PxPhysics physics, PxRigidActor actor0, [Ref] PxTransform localFrame0, PxRigidActor actor1, [Ref] PxTransform localFrame1);
    static PxRevoluteJoint CreateRevoluteJoint([Ref] PxPhysics physics, PxRigidActor actor0, [Ref] PxTransform localFrame0, PxRigidActor actor1, [Ref] PxTransform localFrame1);
    static PxSphericalJoint CreateSphericalJoint([Ref] PxPhysics physics, PxRigidActor actor0, [Ref] PxTransform localFrame0, PxRigidActor actor1, [Ref] PxTransform localFrame1);
    [Value] static PxConvexMeshDesc CreateConvexMeshDesc([Const, Ref] Vector_PxVec3 points);
    static PxConvexMesh CreateConvexMesh([Const, Ref] PxCookingParams params, [Const, Ref] PxConvexMeshDesc desc);
    [Value] static PxTriangleMeshDesc CreateTriangleMeshDesc([Const, Ref] Vector_PxVec3 points, [Const, Ref] Vector_PxU16 triangles);
    static PxTriangleMesh CreateTriangleMesh([Const, Ref] PxCookingParams params, [Const, Ref] PxTriangleMeshDesc desc);
    [Value] static PxHeightFieldDesc CreateHeightFieldDesc(unsigned long nbColumns, unsigned long nbRows, [Const, Ref] Vector_PxHeightFieldSample samples);
    static PxHeightField CreateHeightField([Const, Ref] PxHeightFieldDesc desc);
    static PxRigidStatic CreatePlane([Ref] PxPhysics physics, [Const, Ref] PxPlane plane, [Ref] PxMaterial material, [Ref] PxShapeFlags shapeFlags, [Const, Ref] PxFilterData filterData);
    static readonly attribute unsigned long PHYSICS_VERSION;
};

interface Vector_PxContactPairPoint {
    void Vector_PxContactPairPoint();
    void Vector_PxContactPairPoint(unsigned long size, [Const, Ref] PxContactPairPoint value);
    [Ref] PxContactPairPoint get(unsigned long index);
    void set(unsigned long index, [Const, Ref] PxContactPairPoint value);
    [Const] PxContactPairPoint data();
    [Ref] PxContactPairPoint pushBack([Const, Ref] PxContactPairPoint value);
    void resize(unsigned long size, [Const, Ref] optional PxContactPairPoint value);
    void clear();
};

interface Vector_PxHeightFieldSample {
    void Vector_PxHeightFieldSample();
    void Vector_PxHeightFieldSample(unsigned long size, [Const, Ref] PxHeightFieldSample value);
    [Ref] PxHeightFieldSample get(unsigned long index);
    void set(unsigned long index, [Const, Ref] PxHeightFieldSample value);
    [Const] PxHeightFieldSample data();
    [Ref] PxHeightFieldSample pushBack([Const, Ref] PxHeightFieldSample value);
    void resize(unsigned long size, [Const, Ref] optional PxHeightFieldSample value);
    void clear();
};

interface Vector_PxRaycastHit {
    void Vector_PxRaycastHit();
    void Vector_PxRaycastHit(unsigned long size, [Const, Ref] PxRaycastHit value);
    [Ref] PxRaycastHit get(unsigned long index);
    void set(unsigned long index, [Const, Ref] PxRaycastHit value);
    [Const] PxRaycastHit data();
    [Ref] PxRaycastHit pushBack([Const, Ref] PxRaycastHit value);
    void resize(unsigned long size, [Const, Ref] optional PxRaycastHit value);
    void clear();
};

interface Vector_PxSweepHit {
    void Vector_PxSweepHit();
    void Vector_PxSweepHit(unsigned long size, [Const, Ref] PxSweepHit value);
    [Ref] PxSweepHit get(unsigned long index);
    void set(unsigned long index, [Const, Ref] PxSweepHit value);
    [Const] PxSweepHit data();
    [Ref] PxSweepHit pushBack([Const, Ref] PxSweepHit value);
    void resize(unsigned long size, [Const, Ref] optional PxSweepHit value);
    void clear();
};

interface Vector_PxVec3 {
    void Vector_PxVec3();
    void Vector_PxVec3(unsigned long size, [Const, Ref] PxVec3 value);
    [Ref] PxVec3 get(unsigned long index);
    void set(unsigned long index, [Const, Ref] PxVec3 value);
    [Const] PxVec3 data();
    [Ref] PxVec3 pushBack([Const, Ref] PxVec3 value);
    void resize(unsigned long size, [Const, Ref] optional PxVec3 value);
    void clear();
};

interface Vector_PxU16 {
    void Vector_PxU16();
    void Vector_PxU16(unsigned long size, unsigned short value);
    unsigned short get(unsigned long index);
    void set(unsigned long index, unsigned short value);
    [Const] VoidPtr data();
    unsigned short pushBack(unsigned short value);
    void resize(unsigned long size, optional unsigned short value);
    void clear();
};
